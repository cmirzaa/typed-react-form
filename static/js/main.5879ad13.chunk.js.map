{"version":3,"sources":["../../src/form.ts","../../src/hooks.ts","../../src/elements/FormInput.tsx","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/yup.ts","../../src/Components.tsx","../../src/elements/FormError.tsx","../../src/elements/FormSelect.tsx","../../src/elements/FormTextArea.tsx","VisualRender.tsx","App.tsx","OneOfObjectForm.tsx","OneOfObjectArrayForm.tsx","index.tsx"],"names":["memberCopy","value","Array","Error","comparePrimitiveObject","a","b","ak","Object","bk","lk","i","k","av","bv","FormState","formId","childMap","dirtyMap","errorMap","listeners","anyListeners","counter","this","setValueInternal","isDefault","notifyChild","notifyParent","fireAny","valueMap","child","fireAnyListeners","updateParentValues","validate","validateOnChange","setValue","dirty","values","defaultValues","console","key","setValues","keys","newKeys","setDefaultValues","r","e","validateSync","validator","setError","error","updateParentErrors","setErrors","localKeys","mostKeys","changed","errors","resetAll","reset","setState","c","updateParentState","listen","setters","id","listenAny","ignore","ignoreAny","fireListeners","l","al","ChildFormState","parent","useChildForm","parentForm","name","useRef","useEffect","useListener","form","setRender","useState","defaultValue","state","useAnyListener","useArrayForm","oldLength","val","append","useCallback","remove","newValues","clear","move","to","newArr","target","increment","swap","index","newIndex","getClassName","args","Symbol","iterator","asyncIterator","yupErrorToErrorMap","errorTransformer","obj","err","pathSegments","o","j","oo","props","React","childForm","oldThruthly","thruthly","FormError","rest","FormInput","style","className","disableOnSubmitting","dateAsNumber","errorClassName","errorStyle","dirtyClassName","dirtyStyle","setUndefinedOnUncheck","setNullOnUncheck","hideWhenNull","inputValue","currentValue","useMemo","inValue","inChecked","n","ni","parseInt","isNaN","d","Date","disabled","checked","onChange","newValue","ev","newChecked","parseFloat","arr","FormSelect","children","FormTextArea","validateOnMount","defaultState","isSubmitting","yupSchema","options","messageTransformer","body","recover","result","then","ex","VisualRender","ref","timeoutRef","current","clearTimeout","window","setTimeout","initialValues","Math","ceil","random","description","author","public","date","getTime","dateObject","tags","language","todos","message","priority","TodoListSchema","yup","required","min","of","Form","useForm","yupValidator","onSubmit","preventDefault","Promise","res","display","gridTemplateColumns","gridTemplateRows","gap","margin","type","render","length","map","_","TodoItem","onClick","fill","getFullYear","multiple","age","background","padding","rows","cols","position","top","height","FormValues","fontSize","defaultChecked","show","setShow","overflow","borderRadius","color","undefined","JSON","stringify","AppleOrBreadForm","size","AppleForm","BreadForm","BreadOrAppleForm","ReactDOM","path","exact","component","href","outline","breadOrApple","onReset","log","objects","document","getElementById"],"mappings":"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","file":"static/js/main.5879ad13.chunk.js","sourcesContent":["export type ListenerCallback = () => void;\nexport type ListenerMap = { [T in string]?: ListenerCallback };\nexport type Validator<T, Error> = (values: T) => ErrorMap<T, Error> | Promise<ErrorMap<T, Error>>;\n\nexport type ChildFormMap<T, State, Error> = {\n    [Key in keyof T]?: ChildFormState<T, State, Error, Key>;\n};\n\nexport type DirtyMap<T> = {\n    [Key in keyof T]?: boolean;\n};\n\ntype ObjectOrArray = {\n    [key: string]: any;\n    [key: number]: any;\n};\n\nexport type ErrorType<T, Error> = T extends ObjectOrArray ? ErrorMap<T, Error> | Error : Error;\n\nexport type ErrorMap<T, Error> = {\n    [Key in keyof T]?: ErrorType<T[Key], Error>;\n};\n\nexport type DefaultError = string;\nexport type DefaultState = { isSubmitting: boolean };\n\nexport function memberCopy<T>(value: T): T {\n    if (Array.isArray(value)) {\n        return [...value] as any;\n    } else if (typeof value === \"object\") {\n        return { ...value };\n    } else {\n        throw new Error(\"Can only memberCopy() arrays and objects.\");\n    }\n}\n\n/**\n * Compares 2 objects that only contain primitive fields (no object fields)\n * @returns true when different, false when 'equal', undefined when an object field was found.\n */\nexport function comparePrimitiveObject<T>(a: T, b: T): boolean | undefined {\n    // Compare null and undefined\n    if (!a || !b) return a === b;\n    let ak = Object.keys(a),\n        bk = Object.keys(b);\n    let lk = ak.length > bk.length ? ak : bk;\n    for (let i = 0; i < lk.length; i++) {\n        let k = lk[i];\n        let av = a[k],\n            bv = b[k];\n        if ((typeof av === \"object\" && av !== null) || (typeof bv === \"object\" && bv !== null)) return undefined;\n        if (av !== bv) return true;\n    }\n    return false;\n}\n\nexport class FormState<T, State = DefaultState, Error = DefaultError> {\n    /**\n     * The id of this form, for debugging purposes.\n     */\n    public readonly formId = ++FormState.formCounter;\n\n    /**\n     * The form's validator.\n     */\n    public validator?: Validator<T, Error>;\n\n    /**\n     * Should the form validate on each value change?\n     */\n    public validateOnChange: boolean;\n    public validateOnMount: boolean;\n\n    /**\n     * The values on this form. Use setValues() to set these.\n     */\n    public readonly values: T;\n\n    /**\n     * The default values on this form. Use setDefaultValues(...) to set these.\n     */\n    public readonly defaultValues: T;\n\n    /**\n     * The dictionary that maps object fields to child forms.\n     */\n    public readonly childMap: ChildFormMap<T, State, Error> = {};\n\n    /**\n     * The dictionary that contains dirty states for each field.\n     */\n    public readonly dirtyMap: DirtyMap<T> = {};\n\n    /**\n     * The dictionary that contains errors for each field.\n     */\n    public readonly errorMap: ErrorMap<T, Error> = {};\n\n    private _state: State;\n    private listeners: { [Key in keyof T]?: ListenerMap } = {};\n    private anyListeners: ListenerMap = {};\n    private counter = 0;\n    private static formCounter = 0;\n\n    public constructor(\n        values: T,\n        defaultValues: T,\n        defaultState: State,\n        validator: Validator<T, Error> | undefined,\n        validateOnMount: boolean,\n        validateOnChange: boolean\n    ) {\n        this.values = memberCopy(values);\n        this.defaultValues = memberCopy(defaultValues);\n        this._state = memberCopy(defaultState);\n        this.validator = validator;\n        this.validateOnMount = validateOnMount;\n        this.validateOnChange = validateOnChange;\n    }\n\n    /**\n     * Gets the state of the current form.\n     */\n    public get state() {\n        return this._state;\n    }\n\n    /**\n     * Is this form modified?\n     */\n    public get dirty() {\n        return Object.keys(this.dirtyMap).some((e) => this.dirtyMap[e]);\n    }\n\n    /**\n     * Does this form contain any error?\n     */\n    public get error() {\n        return Object.keys(this.errorMap).some((e) => this.errorMap[e]);\n    }\n\n    /**\n     * Sets a value the advanced way.\n     * @param key The field to set.\n     * @param value The value to set in the field.\n     * @param dirty Is this field dirty? Leave undefined to not set any dirty value. (can always be overridden by child forms)\n     * @param validate Should the form validate after value set? Overrides `validateOnChange`.\n     * @param isDefault Is this the default value for the said field?\n     * @param notifyChild Should this form notify any child form about the change?\n     * @param notifyParent Should this form notify any parent form about the change?\n     * @param setValuesWasUsed Fire all `anyListeners` after field is set? You should not touch this. (will be false for bulk sets, they will call fireAnyListeners() after every field is set)\n     */\n    public setValueInternal<Key extends keyof T>(\n        key: Key,\n        value: T[Key] | undefined,\n        dirty: boolean,\n        validate?: boolean,\n        isDefault: boolean = false,\n        notifyChild: boolean = true,\n        notifyParent: boolean = true,\n        fireAny: boolean = true\n    ) {\n        let valueMap = isDefault ? this.defaultValues : this.values;\n        if (value === undefined) {\n            if (Array.isArray(valueMap)) valueMap.splice(key as number, 1);\n            else delete valueMap[key];\n        } else {\n            valueMap[key] = value;\n        }\n\n        this.dirtyMap[key] = dirty;\n\n        if (notifyChild) {\n            let child = this.childMap[key];\n            if (child && value !== undefined && value !== null) {\n                child.setValues(value!, validate, isDefault, true, false);\n                this.dirtyMap[key] = child.dirty;\n            }\n        }\n\n        this.fireListeners(key);\n        if (fireAny) this.fireAnyListeners(); // Will be false when using setValues, he will call fireAnyListeners and notifyParentValues itself\n        if (notifyParent) this.updateParentValues(isDefault, validate); // Will call setValueInternal on parent\n\n        if (validate ?? (this.validateOnChange && this.validator)) this.validate();\n    }\n\n    /**\n     * Set a value on this form.\n     * @param key The field to set.\n     * @param value The field's new value.\n     * @param validate Should the form validate?\n     * @param isDefault Is this the default value?\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     * @param setValuesWasUsed Fire all `anyListeners` after field is set? You should not touch this. (will be false for bulk sets, they will call fireAnyListeners() after every field is set)\n     */\n    public setValue<Key extends keyof T>(\n        key: Key,\n        value: T[Key] | undefined,\n        validate?: boolean,\n        isDefault: boolean = false,\n        notifyChild: boolean = true,\n        notifyParent: boolean = true,\n        fireAny: boolean = true\n    ) {\n        // value can contain the default value or normal value. (Determined by isDefault)\n        if (typeof value === \"object\" && value !== null) {\n            let dirty: boolean | undefined = false;\n            if (value instanceof Date) {\n                // Compare date objects\n                dirty = value?.getTime() !== (isDefault ? this.values[key] : (this.defaultValues[key] as any))?.getTime();\n            } else if (fireAny) {\n                // Compare primitive objects (objects containing only primitive fields), but only is setValues was not used (dirty value will be determined by child forms)\n                dirty = comparePrimitiveObject(value, isDefault ? this.values[key] : this.defaultValues[key]); // Is switched intentionally\n                if (dirty === undefined) {\n                    console.warn(\n                        \"Do not use setValue for object in object fields, use setValueInternal instead (dirty value can not be determined), \",\n                        key,\n                        value\n                    );\n                    dirty = true;\n                }\n            }\n\n            this.setValueInternal(key, value, dirty, validate, isDefault, notifyChild, notifyParent, fireAny);\n        } else {\n            // Compare value and existing value/defaultValue which determines dirty\n            let dirty = isDefault ? value !== this.values[key] : value !== this.defaultValues[key];\n\n            // Do not set if already set\n            if (((isDefault && this.defaultValues[key] === value) || (!isDefault && this.values[key] === value)) && this.dirtyMap[key] === dirty) {\n                return;\n            }\n\n            this.setValueInternal(key, value, dirty, validate, isDefault, notifyChild, notifyParent, fireAny);\n        }\n    }\n\n    /**\n     * Set all values OR default values on this form.\n     * @param values The new values to set on this form.\n     * @param validate Validate? Overrides `validateOnChange`.\n     * @param isDefault Are these values the default values for this form? This function only updates values or defaultValues, not both! To set both, use `form.setDefaultValues()`.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setValues(values: T, validate?: boolean, isDefault: boolean = false, notifyChild: boolean = true, notifyParent: boolean = true) {\n        let keys = Object.keys(isDefault ? this.defaultValues : this.values);\n        let newKeys = Object.keys(values);\n        for (let i = 0; i < newKeys.length; i++) {\n            if (!keys.includes(newKeys[i])) keys.push(newKeys[i]);\n        }\n        // Traverse backwards, so when removing array items, the whole array gets shifted in the right direction\n        for (let i = keys.length - 1; i >= 0; i--) {\n            let key = keys[i] as keyof T;\n            this.setValue(\n                key,\n                values[key],\n                false, // Will validate after all values are copied\n                isDefault,\n                notifyChild,\n                false, // Will call updateParentValues by itself after all values are copied, see 3 lines down\n                false // Will call fireAnyListener by itself after all values are copied, see 3 lines down\n            );\n        }\n        this.fireAnyListeners();\n        if (notifyParent) this.updateParentValues(isDefault, validate);\n\n        if (validate ?? (this.validateOnChange && this.validator)) this.validate();\n    }\n\n    /**\n     * Set both values and default values for this form. If you only want to set default values, use `setValues(...,...,true)`.\n     * @param values The new default values to set on this form.\n     * @param validate Validate? Overrides `validateOnChange`.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setDefaultValues(values: T, validate: boolean = true, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this.setValues(values, false, true, notifyChild, notifyParent);\n        this.setValues(values, validate, false, notifyChild, notifyParent);\n    }\n\n    /**\n     * Force validation on this form. Required when `validateOnChange` is disabled. **This function works with both asynchronous and synchronous validators.**\n     * @returns true if the form is valid.\n     */\n    public async validate() {\n        if (!this.validator) {\n            return false;\n        }\n        let r = this.validator(this.values);\n        if (r instanceof Promise) r = await r;\n        this.setErrors(r);\n        return !this.error;\n    }\n\n    /**\n     * Force validation on this form. Required when `validateOnChange` is disabled. **This only works if you have a synchronous validator set (not async).**\n     * @returns true if the form is valid.\n     */\n    public validateSync() {\n        if (!this.validator) {\n            return false;\n        }\n        let r = this.validator(this.values);\n        if (r instanceof Promise)\n            throw new Error(\"validateSync() was called on a form with an asynchronous validator set, please use `await form.validate()` instead.\");\n        this.setErrors(r);\n        return !this.error;\n    }\n\n    /**\n     * Sets an error on this form\n     * @param key The field to set an error on.\n     * @param error The error.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     * @param setValuesWasUsed\n     */\n    public setError<Key extends keyof T>(\n        key: Key,\n        error: ErrorType<T[Key], Error> | undefined,\n        notifyChild: boolean = true,\n        notifyParent: boolean = true,\n        fireAny: boolean = true\n    ) {\n        if (typeof error !== \"object\" && this.errorMap[key] === error) return false;\n\n        if (!error) delete this.errorMap[key];\n        else this.errorMap[key] = error;\n\n        if (notifyChild && this.childMap[key]) {\n            let changed = !this.childMap[key]!.setErrors((typeof error === \"object\" ? error ?? {} : {}) as any, true, false);\n            // Only return if the object changed, when a string error was given, this should not return\n            if (changed && typeof error === \"object\") return false;\n        }\n\n        this.fireListeners(key);\n        if (fireAny) this.fireAnyListeners(); // When setValuesWasUsed, it will call fireAnyListener itself when all values were set\n        if (notifyParent) this.updateParentErrors(); // Will call setError on parent\n        return true;\n    }\n\n    /**\n     * Sets all the errors on this form.\n     * @param errors The new errors for this form. Use {} to clear errors. **The format of this error object must follow the same structure of the values object, but each value is replaced by its error.**\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setErrors(errors: ErrorMap<T, Error>, notifyChild: boolean = true, notifyParent: boolean = true) {\n        let localKeys = Object.keys(this.errorMap);\n        let newKeys = Object.keys(errors);\n        let mostKeys = newKeys.length > localKeys.length ? newKeys : localKeys;\n        let changed = false;\n        for (let i = 0; i < mostKeys.length; i++) {\n            let key = mostKeys[i] as keyof T;\n            changed =\n                changed ||\n                this.setError(\n                    key,\n                    errors[key] as any,\n                    notifyChild,\n                    false, // Will call updateParentErrors by itself after all values have been copied, see 3 lines down\n                    false // Will call fireAnyListener by itself after all values have been copied, see 3 lines down\n                );\n        }\n        if (!changed) return false;\n        this.fireAnyListeners();\n        if (notifyParent) this.updateParentErrors();\n        return true;\n    }\n\n    /**\n     * Reset this form's values to the default values.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public resetAll(validate?: boolean, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this.setValues(this.defaultValues, validate ?? true, false, notifyChild, notifyParent);\n    }\n\n    /**\n     * Reset a form's field to its default value.\n     * @param key The field to reset.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public reset(key: keyof T, validate?: boolean, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this.setValue(key, this.defaultValues[key], validate ?? true, false, notifyChild, notifyParent);\n    }\n\n    /**\n     * Sets the state for this form, and also on child and parent forms by default.\n     * @param newState The new form state.\n     * @param notifyChild Set the state on the child too?\n     * @param notifyParent Set the state on the parent too?\n     */\n    public setState(newState: State, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this._state = newState;\n\n        let c = Object.keys(this.values);\n        if (notifyChild) c.forEach((e) => this.childMap[e]?.setState(newState, notifyChild, notifyParent));\n\n        c.forEach((e) => this.fireListeners(e as keyof T));\n        this.fireAnyListeners();\n        if (notifyParent) this.updateParentState();\n    }\n\n    /**\n     * Listen for changes on a field, will trigger when value, defaultValue, dirty and error changes for a field. Make sure you pass its return value back to `ignore()` after you are done listening.\n     * @param key The field to listen to.\n     * @param listener Change callback.\n     */\n    public listen(key: keyof T, listener: ListenerCallback): string {\n        if (!this.listeners) this.listeners = {};\n        let setters = this.listeners[key];\n        if (!setters) {\n            setters = {};\n            this.listeners[key] = setters;\n        }\n        let id = \"\" + this.counter++;\n        setters[id] = listener;\n        return id;\n    }\n\n    /**\n     * Listen for any change on this form. Make sure you pass its return value back to `ignoreAny()` after you are done listening.\n     * @param listener Change callback.\n     */\n    public listenAny(listener: ListenerCallback) {\n        if (!this.anyListeners) this.anyListeners = {};\n        let id = \"\" + this.counter++;\n        this.anyListeners[id] = listener;\n        return id;\n    }\n\n    /**\n     * Ignore changes on a field.\n     * @param key The field to ignore.\n     * @param id The callback to ignore.\n     */\n    public ignore(key: keyof T, id: string) {\n        if (!this.listeners) return;\n        let setters = this.listeners[key];\n        if (!setters) {\n            console.warn(\"Ignore was called for no reason\", key, id);\n            return;\n        }\n        delete setters[id];\n    }\n\n    /**\n     * Ignore changes on this form.\n     * @param id The callback to ignore.\n     */\n    public ignoreAny(id: string) {\n        if (!this.anyListeners) return;\n        delete this.anyListeners[id];\n    }\n\n    protected fireListeners(key: keyof T) {\n        let a = this.listeners[key];\n        if (a) {\n            let l = Object.keys(a!);\n            l.forEach((e) => a![e]!());\n        }\n    }\n\n    protected fireAnyListeners() {\n        let al = Object.keys(this.anyListeners);\n        al.forEach((e) => this.anyListeners[e]!());\n    }\n\n    protected updateParentValues(_isDefault: boolean, _validate: boolean | undefined) {\n        // Not implemented for root form, as it does not have a parent\n    }\n\n    protected updateParentErrors() {\n        // Not implemented for root form, as it does not have a parent\n    }\n\n    protected updateParentState() {\n        // Not implemented for root form, as it does not have a parent\n    }\n}\n\nexport class ChildFormState<Parent, ParentState, ParentError, Key extends keyof Parent> extends FormState<\n    NonNullable<Parent[Key]>,\n    ParentState,\n    ParentError\n> {\n    public name: Key;\n    public readonly parent: FormState<Parent, ParentState, ParentError>;\n\n    public constructor(parent: FormState<Parent, ParentState, ParentError>, name: Key) {\n        super(\n            parent.values[name] ?? ({} as any),\n            parent.defaultValues[name] ?? ({} as any),\n            parent.state,\n            undefined,\n            parent.validateOnMount,\n            parent.validateOnChange\n        );\n        this.parent = parent;\n        this.name = name;\n    }\n\n    protected updateParentValues(isDefault: boolean, validate: boolean | undefined) {\n        this.parent.setValueInternal(\n            this.name,\n            isDefault ? memberCopy(this.defaultValues) : memberCopy(this.values),\n            this.dirty,\n            validate,\n            isDefault,\n            false,\n            true,\n            true\n        );\n    }\n\n    protected updateParentErrors() {\n        this.parent.setError(this.name, this.error ? (memberCopy(this.errorMap) as any) : undefined, false, true);\n    }\n\n    protected updateParentState() {\n        this.parent.setState(memberCopy(this.state), false, true);\n    }\n}\n","import { useRef, useEffect, useState, useCallback } from \"react\";\nimport { DefaultState, DefaultError, FormState, ChildFormState, Validator } from \"./form\";\n\n/**\n * Creates a new root form.\n * This hook doesn't cause a rerender.\n * @param defaultValues The default values for this form.\n * @param validator The validator to use, optional.\n * @param validateOnChange Validate on change? Optional, default is false.\n * @param validateOnChange Validate on mount? Optional, default is false.\n * @param defaultState The default state for this form. Form state contains custom global states, example: isSubmitting, isLoading ... Optional, default is `{ isSubmitting: false }`.\n */\nexport function useForm<T, State = DefaultState, Error = DefaultError>(\n    defaultValues: T,\n    validator?: Validator<T, Error>,\n    validateOnChange = false,\n    validateOnMount = false,\n    defaultState?: State\n) {\n    let c = useRef<FormState<T, State, Error> | null>(null);\n\n    if (!c.current) {\n        c.current = new FormState(\n            defaultValues,\n            defaultValues,\n            defaultState ?? ({ isSubmitting: false } as any),\n            validator,\n            validateOnMount,\n            validateOnChange\n        );\n    }\n\n    useEffect(() => {\n        c.current!.setDefaultValues(defaultValues, c.current!.validateOnMount, true, false);\n    }, [defaultValues]);\n\n    return c.current;\n}\n\n/**\n * Creates a nested form for another root or nested form. You must use this for object and array (see useArrayForm) field.\n * This hook doesn't cause a rerender.\n * @param parentForm The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function useChildForm<T, State, Error, Key extends keyof T>(parentForm: FormState<T, State, Error>, name: Key) {\n    let c = useRef<ChildFormState<T, State, Error, Key> | null>(null);\n    if (!c.current) {\n        c.current = new ChildFormState(parentForm, name);\n    }\n\n    useEffect(() => {\n        // Update parent and child form\n        parentForm.childMap[name] = c.current!;\n        c.current!.name = name;\n\n        // First, set new default values, without validating\n        c.current!.setValues(parentForm.defaultValues[name] ?? ({} as any), false, true, true, false);\n        // Then, set new values and validate if needed\n        c.current!.setValues(parentForm.values[name] ?? ({} as any), c.current!.validateOnMount, false, true, true);\n\n        return () => {\n            // Only clear if is not already overwritten\n            if (parentForm.childMap[name] === c.current!) {\n                delete parentForm.childMap[name];\n            }\n        };\n    }, [parentForm, name]);\n\n    return c.current;\n}\n\n/**\n * Listen for changes on a form's field. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <Listener /> instead.\n * @param form The form to listen on.\n * @param name The form's field to listen to.\n */\nexport function useListener<T, State, Error, Key extends keyof T>(form: FormState<T, State, Error>, name: Key) {\n    const [, setRender] = useState(0);\n\n    useEffect(() => {\n        let id = form.listen(name, () => {\n            setRender((e) => e + 1);\n        });\n        return () => form.ignore(name, id);\n    }, [form, name]);\n\n    return {\n        value: form.values[name],\n        defaultValue: form.defaultValues[name],\n        setValue: (value: T[Key]) => form.setValue(name, value),\n        dirty: form.dirtyMap[name],\n        error: form.errorMap[name],\n        state: form.state,\n        form\n    };\n}\n\n/**\n * Listens for any change on this form. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <AnyListener /> instead.\n * @param form The form to listen to.\n */\nexport function useAnyListener<T, State, Error>(form: FormState<T, State, Error>) {\n    const [, setRender] = useState(0);\n\n    useEffect(() => {\n        let id = form.listenAny(() => {\n            setRender((e) => e + 1);\n        });\n        return () => form.ignoreAny(id);\n    }, [form]);\n\n    return form;\n}\n\n/**\n * This is a wrapper around useChildForm, with useful functions to manipulate arrays.\n * This hook does cause a rerender, but only if the array size changes.\n * @param parentForm The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function useArrayForm<Parent, ParentState, ParentError, Key extends keyof Parent>(\n    parentForm: FormState<Parent, ParentState, ParentError>,\n    name: Key\n) {\n    const form = useChildForm<Parent, ParentState, ParentError, Key>(parentForm, name);\n    const oldLength = useRef(-1);\n    const [, setRender] = useState(0);\n\n    // Only rerender when array size changed\n    useEffect(() => {\n        let id = parentForm.listen(name, () => {\n            let val = parentForm.values[name] as any;\n            if (val.length !== oldLength.current) {\n                setRender((i) => i + 1);\n                oldLength.current = val.length;\n            }\n        });\n        return () => parentForm.ignore(name, id);\n    }, []);\n\n    const append = useCallback((value: NonNullable<Parent[Key]>[any]) => {\n        form.setValues([...(form.values as any), value] as any);\n    }, []);\n\n    const remove = useCallback((index: number) => {\n        let newValues = [...(form.values as any)];\n        newValues.splice(index, 1);\n        form.setValues(newValues as any);\n    }, []);\n\n    const clear = useCallback(() => {\n        form.setValues([] as any);\n    }, []);\n\n    const move = useCallback((from: number, to: number) => {\n        if (to === from) return;\n        let newArr = [...(form.values as any)];\n        var target = newArr[from];\n        var increment = to < from ? -1 : 1;\n        for (var k = from; k !== to; k += increment) {\n            newArr[k] = newArr[k + increment];\n        }\n        newArr[to] = target;\n        form.setValues(newArr as any);\n    }, []);\n\n    const swap = useCallback((index: number, newIndex: number) => {\n        if (index === newIndex) {\n            return;\n        }\n        let values = [...(form.values as any)];\n        [values[index], values[newIndex]] = [values[newIndex], values[index]];\n        form.setValues(values as any);\n    }, []);\n\n    return {\n        remove: remove,\n        move: move,\n        swap: swap,\n        clear: clear,\n        append: append,\n        form: form,\n        values: form.values,\n        setValues: form.setValues.bind(form)\n    };\n}\n","import React, { useMemo } from \"react\";\nimport { InputHTMLAttributes } from \"react\";\nimport { DefaultState, FormState } from \"../form\";\nimport { useListener } from \"../hooks\";\n\ntype BaldInputProps = Omit<InputHTMLAttributes<HTMLInputElement>, \"name\" | \"form\" | \"value\" | \"type\">;\n\nexport const DEFAULT_DIRTY_CLASS = \"typed-form-dirty\";\nexport const DEFAULT_ERROR_CLASS = \"typed-form-error\";\n\nexport function getClassName(...args: any) {\n    return [...args].filter((e) => !!e).join(\" \");\n}\n\nexport type FormInputCheckMode = \"normal\" | \"setNull\" | \"setUndefined\";\n\nexport type FormInputType =\n    | \"number\"\n    | \"text\"\n    | \"password\"\n    | \"date\"\n    | \"datetime-local\"\n    | \"radio\"\n    | \"checkbox\"\n    | \"color\"\n    | \"email\"\n    | \"text\"\n    | \"month\"\n    | \"url\"\n    | \"week\"\n    | \"time\"\n    | \"tel\"\n    | \"range\";\n\nexport type FormInputProps<T, State, Error, Key extends keyof T, Value extends T[Key] | T[Key][keyof T[Key]]> = BaldInputProps & {\n    form: FormState<T, State, Error>;\n    name: Key;\n    type?: FormInputType;\n    value?: Value;\n    errorClassName?: string;\n    errorStyle?: React.CSSProperties;\n    dirtyClassName?: string;\n    dirtyStyle?: React.CSSProperties;\n    disableOnSubmitting?: boolean;\n    dateAsNumber?: boolean;\n    setNullOnUncheck?: boolean;\n    setUndefinedOnUncheck?: boolean;\n    hideWhenNull?: boolean;\n};\n\n/**\n * The builtin form input. You must always specify **form** and **name**. Use the **type** prop to specify what type of field it represents.\n *\n * **FormSelect**, **FormTextArea** and **FormError** are also available.\n *\n * When this component does not satisfy your needs, you can always [create your own](https://github.com/CodeStix/typed-react-form/wiki/Custom-inputs#example-custom-input).\n */\nexport function FormInput<T, State extends DefaultState, Error, Key extends keyof T, Value extends T[Key] | T[Key][keyof T[Key]]>({\n    form,\n    name,\n    style,\n    className,\n    disableOnSubmitting,\n    dateAsNumber,\n    errorClassName,\n    errorStyle,\n    dirtyClassName,\n    dirtyStyle,\n    setUndefinedOnUncheck,\n    setNullOnUncheck,\n    hideWhenNull,\n    value: inputValue,\n    checked: inputChecked,\n    ...rest\n}: FormInputProps<T, State, Error, Key, Value>) {\n    const { value: currentValue, error, dirty, state, setValue, defaultValue } = useListener(form, name);\n\n    let [inValue, inChecked] = useMemo(() => {\n        let inValue = undefined,\n            inChecked = undefined;\n        switch (rest.type) {\n            case \"number\": {\n                inValue = (currentValue ?? \"\") + \"\";\n                break;\n            }\n            case \"datetime-local\":\n            case \"date\": {\n                let n = currentValue as any;\n                if (typeof n === \"string\") {\n                    let ni = parseInt(n);\n                    if (!isNaN(ni)) n = ni;\n                }\n                let d = new Date(n);\n                if (d.getTime() === d.getTime()) {\n                    // Trick to check if date is valid: NaN === NaN returns false\n                    inValue = d?.toISOString().split(\"T\")[0] ?? \"\";\n                } else {\n                    inValue = \"\";\n                }\n                break;\n            }\n            case \"radio\": {\n                inChecked = currentValue === inputValue;\n                break;\n            }\n            case \"checkbox\": {\n                if (setNullOnUncheck) {\n                    inChecked = currentValue !== null;\n                } else if (setUndefinedOnUncheck) {\n                    inChecked = currentValue !== undefined;\n                } else if (inputValue !== undefined) {\n                    inChecked = (Array.isArray(currentValue) ? currentValue : []).includes(inputValue as never);\n                } else {\n                    inChecked = !!currentValue;\n                }\n                break;\n            }\n            default: {\n                inValue = (currentValue ?? \"\") + \"\";\n                break;\n            }\n        }\n        return [inValue, inChecked];\n    }, [rest.type, currentValue, inputValue]);\n\n    if (hideWhenNull && (currentValue === null || currentValue === undefined)) return null;\n\n    if ((setNullOnUncheck || setUndefinedOnUncheck) && rest.type !== \"checkbox\")\n        console.warn(\"setNullOnUncheck/setUndefinedOnUncheck only has an effect on checkboxes.\");\n\n    return (\n        <input\n            style={{\n                ...style,\n                ...(dirty && dirtyStyle),\n                ...(error && errorStyle)\n            }}\n            className={getClassName(className, dirty && (dirtyClassName ?? DEFAULT_DIRTY_CLASS), error && (errorClassName ?? DEFAULT_ERROR_CLASS))}\n            disabled={(disableOnSubmitting ?? true) && state.isSubmitting}\n            value={inValue}\n            checked={inChecked}\n            onChange={(ev) => {\n                let newValue = ev.target.value;\n                let newChecked = ev.target.checked;\n                switch (rest.type) {\n                    case \"number\": {\n                        setValue(parseFloat(newValue) as any);\n                        return;\n                    }\n                    case \"datetime-local\":\n                    case \"date\": {\n                        if (newValue) {\n                            let d = new Date(newValue);\n                            setValue((dateAsNumber ? d.getTime() : d) as any);\n                        } else {\n                            setValue(null as any);\n                        }\n                        return;\n                    }\n                    case \"radio\": {\n                        // Enum field\n                        if (newChecked) {\n                            setValue(inputValue as any);\n                        }\n                        return;\n                    }\n                    case \"checkbox\": {\n                        if (setNullOnUncheck || setUndefinedOnUncheck) {\n                            if (newChecked && inputValue === undefined && !defaultValue)\n                                console.warn(\n                                    \"Toggling checkbox using setNullOnUncheck got checked but a value to set was not found, please provide the value prop\"\n                                );\n                            setValue(\n                                newChecked ? (inputValue !== undefined ? inputValue : defaultValue) : ((setNullOnUncheck ? null : undefined) as any)\n                            );\n                        } else if (inputValue !== undefined) {\n                            // Primitive array field\n                            let arr = Array.isArray(currentValue) ? [...currentValue] : [];\n                            if (newChecked) arr.push(inputValue);\n                            else arr.splice(arr.indexOf(inputValue), 1);\n                            setValue(arr as any);\n                        } else {\n                            // Boolean field\n                            setValue(newChecked as any);\n                        }\n                        return;\n                    }\n                    default: {\n                        // String field\n                        setValue(newValue as any);\n                        return;\n                    }\n                }\n            }}\n            name={name as string}\n            {...rest}\n        />\n    );\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { Validator } from \"./form\";\n\n// yup type stubs\ninterface YupValidationError {\n    path?: string;\n    message?: string;\n    inner: YupValidationError[];\n}\ninterface YupValidationOptions {\n    strict?: boolean;\n    abortEarly?: boolean;\n    stripUnknown?: boolean;\n    recursive?: boolean;\n    context?: any;\n}\n\nexport function yupValidator<T, Error = string>(\n    yupSchema: any,\n    options?: YupValidationOptions,\n    messageTransformer?: (message: string) => Error\n): Validator<T, Error> {\n    return async (values: T) => {\n        try {\n            await yupSchema.validate(values, options);\n            return {};\n        } catch (ex) {\n            return yupErrorToErrorMap(ex, messageTransformer ?? ((e) => e as any));\n        }\n    };\n}\n\nexport function yupErrorToErrorMap<Error>(error: YupValidationError, errorTransformer: (message: string) => Error) {\n    let errors = error.path ? [error] : error.inner;\n    let obj = {};\n    for (let i = 0; i < errors.length; i++) {\n        let err = errors[i];\n        if (!err.path || !err.message) continue;\n        let pathSegments = Array.from(err.path.matchAll(/(\\w+)/gi)).map((e) => e[0]);\n        let o = obj;\n        for (let j = 0; j < pathSegments.length; j++) {\n            let key = pathSegments[j];\n            let oo = o[key];\n            if (!oo) {\n                oo = {};\n                o[key] = oo;\n            }\n            if (j === pathSegments.length - 1) {\n                o[key] = errorTransformer(err.message);\n            } else {\n                o = oo;\n            }\n        }\n    }\n    return obj;\n}\n","import React, { useEffect, useRef, useState } from \"react\";\nimport { ChildFormState, DirtyMap, ErrorMap, FormState } from \"./form\";\nimport { useArrayForm, useListener, useAnyListener, useChildForm } from \"./hooks\";\n\n/**\n * Wrapper around useArrayForm (which is a wrapper around useChildForm).\n * Exports useful functions to manipulate arrays.\n * This hook does cause a rerender, but only if the whole array changes.\n * @param parent The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function ArrayForm<Parent, ParentState, ParentError, Key extends keyof Parent>(props: {\n    form: FormState<Parent, ParentState, ParentError>;\n    name: Key;\n    render?: (props: {\n        form: ChildFormState<Parent, ParentState, ParentError, Key>;\n        remove: (index: number) => void;\n        clear: () => void;\n        move: (index: number, newIndex: number) => void;\n        swap: (index: number, newIndex: number) => void;\n        append: (value: NonNullable<Parent[Key]>[any]) => void;\n        values: NonNullable<Parent[Key]>;\n        setValues: (values: NonNullable<Parent[Key]>) => void;\n    }) => React.ReactNode;\n}) {\n    const childForm = useArrayForm(props.form, props.name);\n    const oldThruthly = useRef(!!props.form.values[props.name]);\n    const [, setRender] = useState(0);\n\n    // Rerender when array became null/not null (thruthly/falsely)\n    useEffect(() => {\n        let id = props.form.listen(props.name, () => {\n            let thruthly = !!props.form.values[props.name];\n            if (thruthly !== oldThruthly.current) {\n                setRender((i) => i + 1);\n                oldThruthly.current = thruthly;\n            }\n        });\n        return () => props.form.ignore(props.name, id);\n    }, []);\n\n    // Do not render anything if the parent field is falsly\n    if (!props.form.values[props.name]) return null;\n    return <React.Fragment>{props.render?.(childForm) ?? childForm.values + \"\"}</React.Fragment>;\n}\n\n/**\n * Wrapper around useListener\n * Listen for changes on a form's field. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <Listener /> instead.\n * @param form The form to listen on.\n * @param name The form's field to listen to.\n */\nexport function Listener<T, State, Error, Key extends keyof T>(props: {\n    form: FormState<T, State, Error>;\n    name: Key;\n    render?: (props: {\n        value: T[Key];\n        defaultValue: T[Key];\n        setValue: (value: T[Key]) => void;\n        dirty: DirtyMap<T>[Key];\n        error: ErrorMap<T, Error>[Key];\n        state: State;\n        form: FormState<T, State, Error>;\n    }) => React.ReactNode;\n}) {\n    const l = useListener(props.form, props.name);\n    return <React.Fragment>{props.render?.(l) ?? l.value + \"\"}</React.Fragment>;\n}\n\n/**\n * Wrapper around useAnyListener.\n * Listens for any change on this form. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <AnyListener /> instead.\n * @param form The form to listen to.\n */\nexport function AnyListener<T, State, Error>(props: {\n    form: FormState<T, State, Error>;\n    render?: (props: FormState<T, State, Error>) => React.ReactNode;\n}) {\n    const l = useAnyListener(props.form);\n    return <React.Fragment>{props.render?.(l) ?? l.values + \"\"}</React.Fragment>;\n}\n\n/**\n * Wrapper around useChildForm\n * Creates a child form for another root or child form. You must use this for object and array (see useArrayForm) fields.\n * This hook doesn't cause a rerender.\n * @param parentForm The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function ChildForm<Parent, ParentState, ParentError, Key extends keyof Parent>(props: {\n    form: FormState<Parent, ParentState, ParentError>; // Use the parent prop instead of the form prop when using ChildForm.\n    name: Key;\n    render?: (props: ChildFormState<Parent, ParentState, ParentError, Key>) => React.ReactNode;\n}) {\n    const childForm = useChildForm(props.form, props.name);\n    const oldThruthly = useRef(!!props.form.values[props.name]);\n    const [, setRender] = useState(0);\n\n    // Only rerender when object became null/not null (thruthly/falsely)\n    useEffect(() => {\n        let id = props.form.listen(props.name, () => {\n            let thruthly = !!props.form.values[props.name];\n            if (thruthly !== oldThruthly.current) {\n                setRender((i) => i + 1);\n                oldThruthly.current = thruthly;\n            }\n        });\n        return () => props.form.ignore(props.name, id);\n    }, []);\n\n    // Do not render anything if the parent field is falsly\n    if (!props.form.values[props.name]) return null;\n    return <React.Fragment>{props.render?.(childForm)}</React.Fragment>;\n}\n","import React, { HTMLAttributes } from \"react\";\nimport { FormState } from \"../form\";\nimport { useListener } from \"../hooks\";\n\nexport type FormErrorProps<T, Error, Key extends keyof T> = Omit<HTMLAttributes<HTMLParagraphElement>, \"name\" | \"form\"> & {\n    form: FormState<T, any, Error>;\n    name: Key;\n};\n\n/**\n * The builtin form error. You must always specify **form** and **name**.\n *\n * **FormInput**, **FormTextArea** and **FormSelect** are also available.\n *\n * When this error component is too basic for your needs, you can always [create your own](https://github.com/CodeStix/typed-react-form/wiki/FormError#custom-error-component).\n */\nexport function FormError<T, Error, Key extends keyof T>({ form, name, ...rest }: FormErrorProps<T, Error, Key>) {\n    const { error } = useListener(form, name);\n    if (!error || typeof error === \"object\") return null;\n    return <p {...rest}>{error + \"\"}</p>;\n}\n","import React, { SelectHTMLAttributes } from \"react\";\nimport { DefaultState, FormState } from \"../form\";\nimport { DEFAULT_DIRTY_CLASS, DEFAULT_ERROR_CLASS, getClassName } from \"./FormInput\";\nimport { useListener } from \"../hooks\";\n\nexport type FormSelectProps<T, State, Error> = Omit<SelectHTMLAttributes<HTMLSelectElement>, \"form\" | \"name\"> & {\n    form: FormState<T, State, Error>;\n    name: keyof T;\n    errorClassName?: string;\n    errorStyle?: React.CSSProperties;\n    dirtyClassName?: string;\n    dirtyStyle?: React.CSSProperties;\n    disableOnSubmitting?: boolean;\n    hideWhenNull?: boolean;\n};\n\n/**\n * The builtin form select. You must always specify **form** and **name**. Use the normal `<option>` element to specify its possible values.\n *\n * **FormInput**, **FormTextArea** and **FormError** are also available.\n *\n * When this component does not satisfy your needs, you can always [create your own](https://github.com/CodeStix/typed-react-form/wiki/Custom-inputs#example-custom-input).\n */\nexport function FormSelect<T, State extends DefaultState, Error>({\n    form,\n    name,\n    errorClassName,\n    errorStyle,\n    dirtyClassName,\n    dirtyStyle,\n    disableOnSubmitting,\n    hideWhenNull,\n    children,\n    className,\n    style,\n    ...rest\n}: FormSelectProps<T, State, Error>) {\n    const { value, setValue, state, dirty, error } = useListener(form, name);\n    if (hideWhenNull && (value === null || value === undefined)) return null;\n    return (\n        <select\n            style={{\n                ...style,\n                ...(dirty && dirtyStyle),\n                ...(error && errorStyle)\n            }}\n            className={getClassName(className, dirty && (dirtyClassName ?? DEFAULT_DIRTY_CLASS), error && (errorClassName ?? DEFAULT_ERROR_CLASS))}\n            disabled={(disableOnSubmitting ?? true) && state.isSubmitting}\n            value={value as any}\n            onChange={(ev) => {\n                if (rest.multiple) setValue(Array.from(ev.target.selectedOptions).map((e) => e.value) as any);\n                else setValue(ev.target.value as any);\n            }}\n            {...rest}\n        >\n            {children}\n        </select>\n    );\n}\n","import React, { TextareaHTMLAttributes } from \"react\";\nimport { DefaultState, FormState } from \"../form\";\nimport { DEFAULT_DIRTY_CLASS, DEFAULT_ERROR_CLASS, getClassName } from \"./FormInput\";\nimport { useListener } from \"../hooks\";\n\nexport type FormTextAreaProps<T, State, Error> = Omit<TextareaHTMLAttributes<HTMLTextAreaElement>, \"form\" | \"name\"> & {\n    form: FormState<T, State, Error>;\n    name: keyof T;\n    errorClassName?: string;\n    errorStyle?: React.CSSProperties;\n    dirtyClassName?: string;\n    dirtyStyle?: React.CSSProperties;\n    disableOnSubmitting?: boolean;\n    hideWhenNull?: boolean;\n};\n\n/**\n * The builtin form textarea. You must always specify **form** and **name**.\n *\n * **FormSelect**, **FormInput** and **FormError** are also available.\n *\n * When this component does not satisfy your needs, you can always [create your own](https://github.com/CodeStix/typed-react-form/wiki/Custom-inputs#example-custom-input).\n */\nexport function FormTextArea<T, State extends DefaultState, Error>({\n    form,\n    name,\n    errorClassName,\n    errorStyle,\n    dirtyClassName,\n    dirtyStyle,\n    disableOnSubmitting,\n    children,\n    className,\n    hideWhenNull,\n    style,\n    ...rest\n}: FormTextAreaProps<T, State, Error>) {\n    const { value, setValue, state, dirty, error } = useListener(form, name);\n    if (hideWhenNull && (value === null || value === undefined)) return null;\n    return (\n        <textarea\n            style={{\n                ...style,\n                ...(dirty && dirtyStyle),\n                ...(error && errorStyle)\n            }}\n            className={getClassName(className, dirty && (dirtyClassName ?? DEFAULT_DIRTY_CLASS), error && (errorClassName ?? DEFAULT_ERROR_CLASS))}\n            disabled={(disableOnSubmitting ?? true) && state.isSubmitting}\n            value={value as any}\n            onChange={(ev) => setValue(ev.target.value as any)}\n            {...rest}\n        >\n            {children}\n        </textarea>\n    );\n}\n","import React, { useRef } from \"react\";\n\nexport function VisualRender(props: { children: React.ReactNode }) {\n    let ref = useRef<HTMLDivElement>(null);\n    let timeoutRef = useRef<number | null>(null);\n\n    if (ref.current) {\n        ref.current.className = \"\";\n        if (timeoutRef.current) clearTimeout(timeoutRef.current);\n        timeoutRef.current = window.setTimeout(() => {\n            ref.current && (ref.current.className = \"blink\");\n        }, 100);\n    }\n\n    return (\n        <div className=\"blink\" ref={ref}>\n            {props.children}\n        </div>\n    );\n}\n","import React, { useState } from \"react\";\nimport {\n    AnyListener,\n    ArrayForm,\n    FormError,\n    FormState,\n    FormInput,\n    FormSelect,\n    useAnyListener,\n    useChildForm,\n    useForm,\n    Listener,\n    FormTextArea,\n    ChildForm,\n    yupValidator,\n    useArrayForm,\n    memberCopy\n} from \"typed-react-form\";\nimport { VisualRender } from \"./VisualRender\";\nimport * as yup from \"yup\";\n\ninterface ExampleFormData {\n    id: number;\n    name: string;\n    description: string;\n    author: User | null;\n    public: boolean;\n    date: number;\n    dateObject: Date;\n    language: \"en\" | \"nl\" | \"fr\";\n    tags: string[];\n    todos: Todo[];\n}\n\ninterface Todo {\n    message: string;\n    priority: \"low\" | \"normal\" | \"high\";\n}\n\ninterface User {\n    name: string;\n    age: number;\n}\n\nexport default function App() {\n    return (\n        <div>\n            <div style={{ padding: \"2em\", background: \"#333\", color: \"white\" }}>\n                <h1>\n                    Example form created using{\" \"}\n                    <a style={{ color: \"#3793ee\" }} href=\"https://github.com/CodeStix/typed-react-form\">\n                        typed-react-form\n                    </a>\n                </h1>\n                <p>\n                    The <strong style={{ color: \"red\" }}>red flash</strong> indicates which parts of the form are being rerendered. The{\" \"}\n                    <strong style={{ outline: \"3px solid gray\" }}>gray outline</strong> indicates that a field is dirty (modified) and the{\" \"}\n                    <strong style={{ outline: \"3px solid red\" }}>red outline</strong> indicates an error.\n                </p>\n                <p>\n                    Every part of this form's{\" \"}\n                    <a style={{ color: \"#3793ee\" }} href=\"https://github.com/CodeStix/typed-react-form/blob/master/example/src/App.tsx\">\n                        source code\n                    </a>{\" \"}\n                    is type-checked.\n                </p>\n            </div>\n            <Form />\n        </div>\n    );\n}\n\nconst initialValues: ExampleFormData = {\n    id: Math.ceil(Math.random() * 100000),\n    name: \"My todo list\",\n    description: \"this is a testing form\",\n    author: null,\n    public: true,\n    date: new Date(\"1990-01-12T00:00:00.000Z\").getTime(),\n    dateObject: new Date(\"1990-01-12T00:00:00.000Z\"),\n    tags: [\"test\"],\n    language: \"en\",\n    todos: [{ message: \"This is a todo\", priority: \"normal\" }]\n};\n\nconst TodoListSchema = yup.object({\n    name: yup.string().required(\"Enter a name\").min(5, \"Enter a longer name\"),\n    todos: yup.array().of(\n        yup.object({\n            message: yup.string().required(\"Enter a todo\")\n        })\n    )\n});\n\nexport function ArrayTest() {\n    const [values, setValues] = useState({ name: \"a list\", items: [\"asdf\"] });\n    const form = useForm(values);\n    const arrayForm = useArrayForm(form, \"items\");\n\n    return (\n        <form\n            onSubmit={(ev) => {\n                ev.preventDefault();\n                console.log(form.values);\n                setValues(memberCopy(form.values));\n            }}\n        >\n            <p>Name</p>\n            <FormInput form={form} name=\"name\" />\n            <p>Items</p>\n            <ul>\n                {arrayForm.values.map((_, i) => (\n                    <li>\n                        <FormInput key={i} form={arrayForm.form} name={i} />\n                        <button type=\"button\" onClick={() => arrayForm.remove(i)}>\n                            Remove\n                        </button>\n                    </li>\n                ))}\n            </ul>\n            <button type=\"button\" onClick={() => arrayForm.append(\"\")}>\n                Add item\n            </button>\n            <button>Submit</button>\n        </form>\n    );\n}\n\nexport function Form() {\n    const form = useForm(\n        initialValues, // <- Default values, may change\n        yupValidator(TodoListSchema), // <- Validator (optional)\n        false, // <- Validate on change (optional)\n        false // <- Validate on mount (optional)\n    );\n\n    return (\n        <form\n            onSubmit={async (ev) => {\n                ev.preventDefault();\n\n                await form.validate(); // Validate manually when validateOnChange is disabled.\n                if (form.error) return; // Do not submit if errors\n\n                form.setState({ isSubmitting: true }); // Set the form state (updates every component listening for state updates)\n\n                await new Promise((res) => setTimeout(res, 1000)); // Fake fetch\n\n                form.setState({ isSubmitting: false }); // Set the form state (updates every component listening for state updates)\n                form.setDefaultValues(form.values); // Set new default values\n            }}\n        >\n            <div style={{ display: \"grid\", gridTemplateColumns: \"60% 40%\", gridTemplateRows: \"100%\", gap: \"2em\", margin: \"2em\" }}>\n                <VisualRender>\n                    <h3>\n                        Id <small>number</small>\n                    </h3>\n                    <FormInput type=\"number\" form={form} name=\"id\" />\n                    <hr />\n                    <h3>\n                        Name <small>string</small>\n                    </h3>\n                    <FormInput form={form} name=\"name\" />\n                    <FormError form={form} name=\"name\" />\n                    <hr />\n                    <h3>\n                        Public? <small>boolean</small>\n                    </h3>\n                    <p>Using radio buttons</p>\n                    <label>\n                        <FormInput type=\"radio\" form={form} name=\"public\" value={false} /> no\n                    </label>\n                    <label>\n                        <FormInput type=\"radio\" form={form} name=\"public\" value={true} /> yes\n                    </label>\n                    <p>Using checkbox</p>\n                    <label>\n                        <FormInput type=\"checkbox\" form={form} name=\"public\" /> yes/no\n                    </label>\n                    <hr />\n                    <h3>\n                        Language <small>enum</small>\n                    </h3>\n                    <p>Using select</p>\n                    <FormSelect form={form} name=\"language\">\n                        <option value=\"en\">English</option>\n                        <option value=\"nl\">Dutch</option>\n                        <option value=\"fr\">French</option>\n                    </FormSelect>\n                    <p>Using radio buttons</p>\n                    <label>\n                        <FormInput type=\"radio\" form={form} name=\"language\" value=\"en\" /> English\n                    </label>\n                    <label>\n                        <FormInput type=\"radio\" form={form} name=\"language\" value=\"nl\" /> Dutch\n                    </label>\n                    <label>\n                        <FormInput type=\"radio\" form={form} name=\"language\" value=\"fr\" /> French\n                    </label>\n                    <hr />\n                    <h3>\n                        Todo's <small>dynamic array</small>\n                    </h3>\n                    {/* Use ArrayForm (wrapper around useArrayForm) to create dynamic forms */}\n                    <FormError form={form} name=\"todos\" />\n                    <ArrayForm\n                        form={form}\n                        name=\"todos\"\n                        render={(\n                            { form, swap, remove, append, values, setValues } // <- Make sure to use the newly passed form (otherwise type checking will not work!)\n                        ) => (\n                            <VisualRender>\n                                <pre>{form.values.length}</pre>\n                                <ul>\n                                    {form.values.map((\n                                        _,\n                                        i // You should use other key than index\n                                    ) => (\n                                        <TodoItem swap={swap} remove={remove} key={i} parent={form} index={i} />\n                                    ))}\n                                </ul>\n                                <button\n                                    type=\"button\"\n                                    onClick={() => {\n                                        append({\n                                            message: \"\",\n                                            priority: \"normal\"\n                                        });\n                                    }}\n                                >\n                                    Add item\n                                </button>\n                                <button\n                                    type=\"button\"\n                                    onClick={() => {\n                                        setValues([\n                                            ...values,\n                                            ...Array(10)\n                                                .fill(0)\n                                                .map((_, i) => ({\n                                                    message: \"Fix this \" + i,\n                                                    priority: \"normal\" as \"normal\" // Wut\n                                                }))\n                                        ]);\n                                    }}\n                                >\n                                    Add 10 items\n                                </button>\n                            </VisualRender>\n                        )}\n                    />\n                    <button type=\"button\" onClick={() => form.setError(\"todos\", \"There is something wrong with the array\")}>\n                        Set array error\n                    </button>\n                    <hr />\n                    <h3>\n                        Date <small>timestamp number</small>\n                    </h3>\n                    <FormInput type=\"date\" form={form} name=\"date\" dateAsNumber />\n                    <hr />\n                    <h3>\n                        Date <small>date object</small>\n                    </h3>\n                    <FormInput type=\"date\" form={form} name=\"dateObject\" />\n                    <Listener\n                        form={form}\n                        name=\"dateObject\"\n                        render={({ value }) => <p>Your age is {new Date().getFullYear() - value.getFullYear()}</p>}\n                    />\n                    <hr />\n                    <h3>\n                        Tags <small>string array</small>\n                    </h3>\n                    <p>\n                        Using select with <code>multiple=true</code>\n                    </p>\n                    <FormSelect form={form} name=\"tags\" multiple>\n                        <option value=\"test\">Test</option>\n                        <option value=\"fun\">Fun</option>\n                        <option value=\"school\">School</option>\n                    </FormSelect>\n                    <p>Using checkboxes</p>\n                    <label>\n                        <FormInput form={form} name=\"tags\" type=\"checkbox\" value=\"test\" />\n                        Test\n                    </label>\n                    <label>\n                        <FormInput form={form} name=\"tags\" type=\"checkbox\" value=\"fun\" />\n                        Fun\n                    </label>\n                    <label>\n                        <FormInput form={form} name=\"tags\" type=\"checkbox\" value=\"school\" />\n                        School\n                    </label>\n                    <hr />\n                    <h3>Togglable object field</h3>\n                    <label>\n                        <FormInput form={form} name=\"author\" type=\"checkbox\" setNullOnUncheck value={{ name: \"\", age: 0 }} />\n                        Enable author\n                    </label>\n                    <ChildForm\n                        form={form}\n                        name=\"author\"\n                        render={(form) => (\n                            <VisualRender>\n                                <div style={{ background: \"#0001\", padding: \"1em\" }}>\n                                    <p>Name</p>\n                                    <FormInput form={form} name=\"name\" />\n                                    <p>Age</p>\n                                    <FormInput form={form} name=\"age\" type=\"number\" />\n                                </div>\n                            </VisualRender>\n                        )}\n                    />\n                    <hr />\n                    <h3>\n                        Description <small>string</small>\n                    </h3>\n                    <p>\n                        Using <code>FormTextArea</code>\n                    </p>\n                    <FormTextArea form={form} name=\"description\" rows={5} cols={50} />\n                    <p>\n                        Using <code>Listener</code> around <code>textarea</code>\n                    </p>\n                    <Listener\n                        form={form}\n                        name=\"description\"\n                        render={({ value, setValue }) => (\n                            <textarea rows={5} cols={50} value={value} onChange={(ev) => setValue(ev.target.value)}></textarea>\n                        )}\n                    />\n                </VisualRender>\n                <div style={{ position: \"sticky\", top: \"0\", height: \"500px\" }}>\n                    <h2>Output</h2>\n                    <FormValues form={form} />\n\n                    {/* Disable buttons when form is submitting or when nothing has changed, the AnyListener wrapper is required */}\n                    <AnyListener\n                        form={form}\n                        render={({ state, dirty }) => (\n                            <div style={{ margin: \"0.5em 0\" }}>\n                                <button style={{ fontSize: \"1.3em\" }} disabled={state.isSubmitting || !dirty}>\n                                    Submit\n                                </button>\n                                <button\n                                    style={{ fontSize: \"1.3em\" }}\n                                    disabled={state.isSubmitting || !dirty}\n                                    type=\"button\"\n                                    onClick={() => form.resetAll()}\n                                >\n                                    Reset\n                                </button>\n                            </div>\n                        )}\n                    />\n\n                    <div>\n                        <button style={{ fontSize: \"1.3em\" }} type=\"button\" onClick={() => form.validate()}>\n                            Validate\n                        </button>\n                        <label>\n                            <code>validateOnChange</code>\n                            <input\n                                type=\"checkbox\"\n                                defaultChecked={form.validateOnChange}\n                                onChange={(e) => (form.validateOnChange = e.target.checked)}\n                            />\n                        </label>\n                    </div>\n                </div>\n            </div>\n        </form>\n    );\n}\n\nfunction TodoItem(props: {\n    key: number;\n    parent: FormState<Todo[]>;\n    index: number;\n    swap: (a: number, b: number) => void;\n    remove: (a: number) => void;\n}) {\n    // Use a child form, each layer in the object is a seperate form: TodoList (useForm) -> Todo[] (useArrayForm) -> Todo (useChildForm)\n    const form = useChildForm(props.parent, props.index);\n\n    return (\n        <li\n            style={{\n                padding: \"0.5em\"\n            }}\n        >\n            <VisualRender>\n                <FormInput form={form} name=\"message\" />\n                <FormSelect form={form} name=\"priority\">\n                    <option value=\"low\">Low</option>\n                    <option value=\"normal\">Normal</option>\n                    <option value=\"high\">High</option>\n                </FormSelect>\n                <button type=\"button\" onClick={() => props.swap(props.index, 0)}>\n                    Go to top\n                </button>\n                <button type=\"button\" onClick={() => props.remove(props.index)}>\n                    Remove\n                </button>\n            </VisualRender>\n        </li>\n    );\n}\n\n/**\n *  Shows a JSON representation of a form\n */\nfunction FormValues<T>(props: { form: FormState<T> }) {\n    const form = useAnyListener(props.form);\n    const [show, setShow] = useState({ values: true, defaultValues: false, errorMap: true, dirtyMap: true, state: false });\n    return (\n        <VisualRender>\n            <div style={{ background: \"#0001\", overflow: \"hidden\", padding: \"1em\", borderRadius: \"1em\" }}>\n                <p>\n                    <strong style={{ color: form.dirty ? \"blue\" : undefined }}>{form.dirty ? \"Modified\" : \"Unmodified\"}</strong>\n                </p>\n                <p>\n                    <strong style={{ color: form.error ? \"red\" : undefined }}>{form.error ? \"Has error\" : \"No errors\"}</strong>\n                </p>\n\n                <div>\n                    <strong>Show: </strong>\n                    <label>\n                        <input type=\"checkbox\" checked={show.values} onChange={(ev) => setShow({ ...show, values: ev.target.checked })} />\n                        <code>values</code>\n                    </label>\n                    <label>\n                        <input\n                            type=\"checkbox\"\n                            checked={show.defaultValues}\n                            onChange={(ev) => setShow({ ...show, defaultValues: ev.target.checked })}\n                        />\n                        <code>defaultValues</code>\n                    </label>\n                    <label>\n                        <input type=\"checkbox\" checked={show.errorMap} onChange={(ev) => setShow({ ...show, errorMap: ev.target.checked })} />\n                        <code>errorMap</code>\n                    </label>\n                    <label>\n                        <input type=\"checkbox\" checked={show.dirtyMap} onChange={(ev) => setShow({ ...show, dirtyMap: ev.target.checked })} />\n                        <code>dirtyMap</code>\n                    </label>\n                    <label>\n                        <input type=\"checkbox\" checked={show.state} onChange={(ev) => setShow({ ...show, state: ev.target.checked })} />\n                        <code>state</code>\n                    </label>\n                </div>\n\n                {show.values && <pre>values = {JSON.stringify(form.values, null, 2)}</pre>}\n                {show.defaultValues && <pre>defaultValues = {JSON.stringify(form.defaultValues, null, 2)}</pre>}\n                {show.errorMap && <pre>errorMap = {JSON.stringify(form.errorMap, null, 2)}</pre>}\n                {show.dirtyMap && <pre>dirtyMap = {JSON.stringify(form.dirtyMap, null, 2)}</pre>}\n                {show.state && <pre>state = {JSON.stringify(form.state, null, 2)}</pre>}\n            </div>\n        </VisualRender>\n    );\n}\n\n// You should use a validation library (yup, class-validator) instead of this mess...\n// function validateTodoList(values: ExampleFormData) {\n//     let todoErrors = values.todos.reduce((prev, val, index) => {\n//         if (val.message.length < 5) {\n//             prev[index] = { message: \"Todo message should be longer!\" };\n//         }\n//         return prev;\n//     }, [] as any[]);\n//     return {\n//         // author: values.author.length < 3 ? \"Author name is too short.\" : undefined,\n//         name: values.name.length < 3 ? \"Title is too short.\" : undefined,\n//         todos: todoErrors.length > 0 ? todoErrors : undefined\n//     };\n// }\n","import React from \"react\";\nimport { AnyListener, FormInput, FormState, Listener, useChildForm, useForm } from \"typed-react-form\";\n\ninterface Apple {\n    type: \"apple\";\n    color: string;\n}\n\ninterface Bread {\n    type: \"bread\";\n    size: number;\n}\n\ninterface FormData {\n    breadOrApple: Apple | Bread;\n}\n\nexport default function OneOfObjectArrayForm() {\n    const form = useForm<FormData>({\n        breadOrApple: { type: \"apple\", color: \"#ff0000\" } // or { type: \"bread\", size: 200 }\n    });\n    return (\n        <form\n            style={{ margin: \"0.5em\" }}\n            onReset={() => form.resetAll()}\n            onSubmit={async (ev) => {\n                // Prevent the submit button from reloading the page\n                ev.preventDefault();\n                // Disable inputs and fake submit...\n                form.setState({ isSubmitting: true });\n                await new Promise((res) => setTimeout(res, 500));\n                form.setState({ isSubmitting: false });\n                console.log(form.values);\n                form.setDefaultValues(form.values);\n            }}\n        >\n            <a href=\"https://github.com/CodeStix/typed-react-form/blob/master/example/src/OneOfObjectForm.tsx\">View source code</a>\n\n            {/* Our custom form component */}\n            <AppleOrBreadForm parent={form} />\n\n            {/* Shows a live representation of the form values */}\n            <AnyListener\n                form={form}\n                render={({ values, dirty }) => (\n                    <pre>\n                        {dirty ? \"MODIFIED\" : \"UNMODIFIED\"}\n                        <br />\n                        {JSON.stringify(values, null, 2)}\n                    </pre>\n                )}\n            />\n\n            <button>Submit!</button>\n            <button type=\"reset\">Reset</button>\n        </form>\n    );\n}\n\nfunction AppleOrBreadForm(props: { parent: FormState<FormData> }) {\n    // Create a new form based on the 'breadOrApple' field\n    const form = useChildForm(props.parent, \"breadOrApple\");\n    return (\n        <div style={{ background: \"#0001\", padding: \"1em\", margin: \"1em\" }}>\n            <label>Object type: </label>\n            {/* You can also use the useListener hook instead */}\n            <Listener\n                form={form}\n                name=\"type\"\n                render={({ value }) => (\n                    <>\n                        {/* A select input that sets new form values when a new object type (apple or bread) was chosen */}\n                        <select\n                            value={value}\n                            onChange={(ev) => {\n                                if (ev.target.value === \"apple\") form.setValues({ type: \"apple\", color: \"#ff0000\" });\n                                else if (ev.target.value === \"bread\") form.setValues({ type: \"bread\", size: 200 });\n                            }}\n                        >\n                            <option value=\"apple\">Apple</option>\n                            <option value=\"bread\">Bread</option>\n                        </select>\n\n                        {/* Render AppleForm when the type is 'apple'. When type is 'bread', render BreadForm */}\n                        {value === \"apple\" ? <AppleForm form={form as FormState<Apple>} /> : <BreadForm form={form as FormState<Bread>} />}\n                    </>\n                )}\n            />\n        </div>\n    );\n}\n\nfunction AppleForm({ form }: { form: FormState<Apple> }) {\n    return (\n        <div>\n            <h4>Apple editor</h4>\n            <p>Select the color of your apple</p>\n            <FormInput form={form} type=\"color\" name=\"color\" />\n        </div>\n    );\n}\n\nfunction BreadForm({ form }: { form: FormState<Bread> }) {\n    return (\n        <div>\n            <h4>Bread editor</h4>\n            <p>Select the size of your bread</p>\n            <FormInput form={form} type=\"number\" name=\"size\" />\n        </div>\n    );\n}\n","import React from \"react\";\nimport { AnyListener, ArrayForm, FormInput, FormState, useChildForm, useForm, useListener } from \"typed-react-form\";\n\ninterface Apple {\n    type: \"apple\";\n    color: string;\n}\n\ninterface Bread {\n    type: \"bread\";\n    size: number;\n}\n\ntype FormDataObject = Apple | Bread;\n\ninterface FormData {\n    objects: FormDataObject[];\n}\n\nexport default function OneOfObjectArrayForm() {\n    const form = useForm<FormData>({\n        objects: [\n            { type: \"apple\", color: \"#ff0000\" },\n            { type: \"bread\", size: 200 }\n        ]\n    });\n    return (\n        <form\n            style={{ margin: \"0.5em\" }}\n            onReset={() => form.resetAll()}\n            onSubmit={async (ev) => {\n                // Prevent the submit button from reloading the page\n                ev.preventDefault();\n                // Disable inputs and fake submit...\n                form.setState({ isSubmitting: true });\n                await new Promise((res) => setTimeout(res, 500));\n                form.setState({ isSubmitting: false });\n                console.log(form.values);\n                form.setDefaultValues(form.values);\n            }}\n        >\n            <a href=\"https://github.com/CodeStix/typed-react-form/blob/master/example/src/OneOfObjectArrayForm.tsx\">View source code</a>\n            <ArrayForm\n                form={form}\n                name=\"objects\"\n                render={({ form, values, append, remove }) => (\n                    <>\n                        <ul>\n                            {values.map((_, i) => (\n                                // Use index as key\n                                <li key={i}>\n                                    {/* Make sure to use the form given by ArrayForm! */}\n                                    <BreadOrAppleForm parent={form} index={i} remove={() => remove(i)} />\n                                </li>\n                            ))}\n                        </ul>\n                        <hr />\n                        <button type=\"button\" onClick={() => append({ type: \"apple\", color: \"#ff0000\" })}>\n                            Add Apple\n                        </button>\n                        <button type=\"button\" onClick={() => append({ type: \"bread\", size: 200 })}>\n                            Add Bread\n                        </button>\n                    </>\n                )}\n            />\n            <AnyListener\n                form={form}\n                render={({ values, dirty }) => (\n                    <pre>\n                        {dirty ? \"MODIFIED\" : \"UNMODIFIED\"}\n                        <br />\n                        {JSON.stringify(values, null, 2)}\n                    </pre>\n                )}\n            />\n            <button>Submit!</button>\n            <button type=\"reset\">Reset</button>\n        </form>\n    );\n}\n\nfunction BreadOrAppleForm(props: { parent: FormState<FormDataObject[]>; index: number; remove: () => void }) {\n    // Create a new child form with the array as the parent and index as the key\n    const form = useChildForm(props.parent, props.index);\n    // Listen for changes on the 'type' field, which contains 'apple' or 'bread'. This component will rerender when it changes\n    const { value: type } = useListener(form, \"type\");\n    return (\n        <div style={{ background: \"#0001\", padding: \"1em\", margin: \"1em\" }}>\n            {/* A select input that sets new form values when a new object type (apple or bread) was chosen */}\n            <label>Object type: </label>\n            <select\n                value={type}\n                onChange={(ev) => {\n                    if (ev.target.value === \"apple\") form.setValues({ type: \"apple\", color: \"red\" });\n                    else if (ev.target.value === \"bread\") form.setValues({ type: \"bread\", size: 200 });\n                }}\n            >\n                <option value=\"apple\">Apple</option>\n                <option value=\"bread\">Bread</option>\n            </select>\n\n            {/* Render AppleForm when the type is 'apple'. When type is 'bread', render BreadForm */}\n            {type === \"apple\" ? <AppleForm form={form as FormState<Apple>} /> : <BreadForm form={form as FormState<Bread>} />}\n\n            {/* Remove this item from the list */}\n            <button type=\"button\" onClick={() => props.remove()}>\n                Remove\n            </button>\n        </div>\n    );\n}\n\nfunction AppleForm({ form }: { form: FormState<Apple> }) {\n    return (\n        <div>\n            <h4>Apple editor</h4>\n            <p>Select the color of your apple</p>\n            <FormInput form={form} type=\"color\" name=\"color\" />\n        </div>\n    );\n}\n\nfunction BreadForm({ form }: { form: FormState<Bread> }) {\n    return (\n        <div>\n            <h4>Bread editor</h4>\n            <p>Select the size of your bread</p>\n            <FormInput form={form} type=\"number\" name=\"size\" />\n        </div>\n    );\n}\n","import \"./index.css\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport OneOfObjectForm from \"./OneOfObjectForm\";\nimport OneOfObjectArrayForm from \"./OneOfObjectArrayForm\";\nimport { BrowserRouter as Router, Route } from \"react-router-dom\";\n\nReactDOM.render(\n    <Router>\n        <Route path=\"/\" exact component={App} />\n        <Route path=\"/object-types\" exact component={OneOfObjectForm} />\n        <Route path=\"/object-types-array\" exact component={OneOfObjectArrayForm} />\n    </Router>,\n    document.getElementById(\"root\")\n);\n"],"sourceRoot":""}