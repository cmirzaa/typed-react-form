{"version":3,"sources":["../../src/form.ts","../../src/hooks.ts","../../src/elements/FormInput.tsx","../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../../src/yup.ts","../../src/Components.tsx","../../src/elements/FormError.tsx","../../src/elements/FormSelect.tsx","../../src/elements/FormTextArea.tsx","VisualRender.tsx","App.tsx","OneOfObjectForm.tsx","OneOfObjectArrayForm.tsx","index.tsx"],"names":["memberCopy","value","Array","Error","comparePrimitiveObject","a","b","ak","Object","bk","lk","i","k","av","bv","FormState","formId","childMap","dirtyMap","errorMap","listeners","anyListeners","counter","this","setValueInternal","isDefault","notifyChild","notifyParent","fireAny","valueMap","child","fireAnyListeners","updateParentValues","validate","validateOnChange","setValue","dirty","values","defaultValues","console","key","setValues","keys","newKeys","setDefaultValues","r","e","validateSync","validator","setError","error","updateParentErrors","setErrors","changed","errors","resetAll","reset","setState","c","updateParentState","listen","setters","id","listenAny","ignore","ignoreAny","fireListeners","l","al","ChildFormState","parent","useChildForm","parentForm","name","useRef","useEffect","useListener","form","setRender","useState","defaultValue","state","useAnyListener","useArrayForm","oldLength","val","append","useCallback","remove","newValues","clear","move","to","newArr","target","increment","swap","index","newIndex","useTruthyListener","oldTruthy","thruthly","getClassName","args","Symbol","iterator","asyncIterator","yupErrorToErrorMap","errorTransformer","obj","err","pathSegments","o","j","oo","props","React","childForm","FormError","rest","FormInput","style","className","disableOnSubmitting","dateAsNumber","errorClassName","errorStyle","dirtyClassName","dirtyStyle","setUndefinedOnUncheck","setNullOnUncheck","hideWhenNull","inputValue","currentValue","useMemo","inValue","inChecked","n","ni","parseInt","isNaN","d","Date","disabled","checked","onChange","newValue","ev","newChecked","parseFloat","arr","FormSelect","children","FormTextArea","validateOnMount","defaultState","isSubmitting","yupSchema","options","messageTransformer","body","recover","result","then","ex","VisualRender","ref","timeoutRef","current","clearTimeout","window","setTimeout","App","padding","background","color","href","outline","Form","initialValues","Math","ceil","random","description","author","public","date","getTime","dateObject","tags","language","todos","message","priority","TodoListSchema","yup","required","min","oneOf","of","useForm","yupValidator","abortEarly","onSubmit","preventDefault","Promise","res","display","gridTemplateColumns","gridTemplateRows","gap","margin","type","render","length","map","_","TodoItem","onClick","fill","getFullYear","multiple","age","rows","cols","position","top","height","FormValues","fontSize","defaultChecked","show","setShow","overflow","borderRadius","undefined","JSON","stringify","OneOfObjectArrayForm","breadOrApple","onReset","log","AppleOrBreadForm","size","AppleForm","BreadForm","objects","BreadOrAppleForm","Router","location","hash","ReactDOM","document","getElementById"],"mappings":"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","file":"static/js/main.4f7f0eb2.chunk.js","sourcesContent":["export type ListenerCallback = () => void;\nexport type ListenerMap = { [T in string]?: ListenerCallback };\nexport type Validator<T, Error> = (values: T) => ErrorMap<T, Error> | Promise<ErrorMap<T, Error>>;\n\nexport type ChildFormMap<T, State, Error extends string> = {\n    [Key in keyof T]?: ChildFormState<T, Key, State, Error>;\n};\n\nexport type DirtyMap<T> = {\n    [Key in keyof T]?: boolean;\n};\n\nexport type ErrorType<T, Error> = T extends object ? ErrorMap<T, Error> | Error : Error;\n\nexport type ErrorMap<T, Error> = {\n    [Key in keyof T]?: ErrorType<T[Key], Error>;\n};\n\nexport type DefaultError = string;\nexport type DefaultState = { isSubmitting: boolean };\n\nexport function memberCopy<T>(value: T): T {\n    if (Array.isArray(value)) {\n        return [...value] as any;\n    } else if (typeof value === \"object\") {\n        return { ...value };\n    } else {\n        throw new Error(\"Can only memberCopy() arrays and objects.\");\n    }\n}\n\n/**\n * Compares 2 objects that only contain primitive fields (no object fields)\n * @returns true when different, false when 'equal', undefined when an object field was found.\n */\nexport function comparePrimitiveObject<T>(a: T, b: T): boolean | undefined {\n    // Compare null and undefined\n    if (!a || !b) return a === b;\n    let ak = Object.keys(a),\n        bk = Object.keys(b);\n    let lk = ak.length > bk.length ? ak : bk;\n    for (let i = 0; i < lk.length; i++) {\n        let k = lk[i];\n        let av = a[k],\n            bv = b[k];\n        if ((typeof av === \"object\" && av !== null) || (typeof bv === \"object\" && bv !== null)) return undefined;\n        if (av !== bv) return true;\n    }\n    return false;\n}\n\nexport class FormState<T, State = DefaultState, Error extends string = DefaultError> {\n    /**\n     * The id of this form, for debugging purposes.\n     */\n    public readonly formId = ++FormState.formCounter;\n\n    /**\n     * The form's validator.\n     */\n    public validator?: Validator<T, Error>;\n\n    /**\n     * Should the form validate on each value change?\n     */\n    public validateOnChange: boolean;\n    public validateOnMount: boolean;\n\n    /**\n     * The values on this form. Use setValues() to set these.\n     */\n    public readonly values: T;\n\n    /**\n     * The default values on this form. Use setDefaultValues(...) to set these.\n     */\n    public readonly defaultValues: T;\n\n    /**\n     * The dictionary that maps object fields to child forms.\n     */\n    public readonly childMap: ChildFormMap<T, State, Error> = {};\n\n    /**\n     * The dictionary that contains dirty states for each field.\n     */\n    public readonly dirtyMap: DirtyMap<T> = {};\n\n    /**\n     * The dictionary that contains errors for each field.\n     */\n    public readonly errorMap: ErrorMap<T, Error> = {};\n\n    private _state: State;\n    private listeners: { [Key in keyof T]?: ListenerMap } = {};\n    private anyListeners: ListenerMap = {};\n    private counter = 0;\n    private static formCounter = 0;\n\n    public constructor(\n        values: T,\n        defaultValues: T,\n        defaultState: State,\n        validator: Validator<T, Error> | undefined,\n        validateOnMount: boolean,\n        validateOnChange: boolean\n    ) {\n        this.values = memberCopy(values);\n        this.defaultValues = memberCopy(defaultValues);\n        this._state = memberCopy(defaultState);\n        this.validator = validator;\n        this.validateOnMount = validateOnMount;\n        this.validateOnChange = validateOnChange;\n    }\n\n    /**\n     * Gets the state of the current form.\n     */\n    public get state() {\n        return this._state;\n    }\n\n    /**\n     * Is this form modified?\n     */\n    public get dirty() {\n        return Object.keys(this.dirtyMap).some((e) => this.dirtyMap[e]);\n    }\n\n    /**\n     * Does this form contain any error?\n     */\n    public get error() {\n        return Object.keys(this.errorMap).some((e) => this.errorMap[e]);\n    }\n\n    /**\n     * Sets a value the advanced way.\n     * @param key The field to set.\n     * @param value The value to set in the field.\n     * @param dirty Is this field dirty? Leave undefined to not set any dirty value. (can always be overridden by child forms)\n     * @param validate Should the form validate after value set? Overrides `validateOnChange`.\n     * @param isDefault Is this the default value for the said field?\n     * @param notifyChild Should this form notify any child form about the change?\n     * @param notifyParent Should this form notify any parent form about the change?\n     * @param setValuesWasUsed Fire all `anyListeners` after field is set? You should not touch this. (will be false for bulk sets, they will call fireAnyListeners() after every field is set)\n     */\n    public setValueInternal<Key extends keyof T>(\n        key: Key,\n        value: T[Key] | undefined,\n        dirty: boolean,\n        validate?: boolean,\n        isDefault: boolean = false,\n        notifyChild: boolean = true,\n        notifyParent: boolean = true,\n        fireAny: boolean = true\n    ) {\n        let valueMap = isDefault ? this.defaultValues : this.values;\n        if (value === undefined) {\n            if (Array.isArray(valueMap)) valueMap.splice(key as number, 1);\n            else delete valueMap[key];\n        } else {\n            valueMap[key] = value;\n        }\n\n        this.dirtyMap[key] = dirty;\n\n        if (notifyChild) {\n            let child = this.childMap[key];\n            if (child && value !== undefined && value !== null) {\n                child.setValues(value!, validate, isDefault, true, false);\n                this.dirtyMap[key] = child.dirty;\n            }\n        }\n\n        this.fireListeners(key);\n        if (fireAny) this.fireAnyListeners(); // Will be false when using setValues, he will call fireAnyListeners and notifyParentValues itself\n        if (notifyParent) this.updateParentValues(isDefault, validate); // Will call setValueInternal on parent\n\n        if (validate ?? (this.validateOnChange && this.validator)) this.validate();\n    }\n\n    /**\n     * Set a value on this form.\n     * @param key The field to set.\n     * @param value The field's new value.\n     * @param validate Should the form validate?\n     * @param isDefault Is this the default value?\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     * @param setValuesWasUsed Fire all `anyListeners` after field is set? You should not touch this. (will be false for bulk sets, they will call fireAnyListeners() after every field is set)\n     */\n    public setValue<Key extends keyof T>(\n        key: Key,\n        value: T[Key] | undefined,\n        validate?: boolean,\n        isDefault: boolean = false,\n        notifyChild: boolean = true,\n        notifyParent: boolean = true,\n        fireAny: boolean = true\n    ) {\n        // value can contain the default value or normal value. (Determined by isDefault)\n        if (typeof value === \"object\" && value !== null) {\n            let dirty: boolean | undefined = false;\n            if (value instanceof Date) {\n                // Compare date objects\n                dirty = value?.getTime() !== (isDefault ? this.values[key] : (this.defaultValues[key] as any))?.getTime();\n            } else if (fireAny) {\n                // Compare primitive objects (objects containing only primitive fields), but only is setValues was not used (dirty value will be determined by child forms)\n                dirty = comparePrimitiveObject(value, isDefault ? this.values[key] : this.defaultValues[key]); // Is switched intentionally\n                if (dirty === undefined) {\n                    console.warn(\n                        \"Do not use setValue for object in object fields, use setValueInternal instead (dirty value can not be determined), \",\n                        key,\n                        value\n                    );\n                    dirty = true;\n                }\n            }\n\n            this.setValueInternal(key, value, dirty, validate, isDefault, notifyChild, notifyParent, fireAny);\n        } else {\n            // Compare value and existing value/defaultValue which determines dirty\n            let dirty = isDefault ? value !== this.values[key] : value !== this.defaultValues[key];\n\n            // Do not set if already set\n            if (((isDefault && this.defaultValues[key] === value) || (!isDefault && this.values[key] === value)) && this.dirtyMap[key] === dirty) {\n                return;\n            }\n\n            this.setValueInternal(key, value, dirty, validate, isDefault, notifyChild, notifyParent, fireAny);\n        }\n    }\n\n    /**\n     * Set all values OR default values on this form.\n     * @param values The new values to set on this form.\n     * @param validate Validate? Overrides `validateOnChange`.\n     * @param isDefault Are these values the default values for this form? This function only updates values or defaultValues, not both! To set both, use `form.setDefaultValues()`.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setValues(values: T, validate?: boolean, isDefault: boolean = false, notifyChild: boolean = true, notifyParent: boolean = true) {\n        let keys = Object.keys(isDefault ? this.defaultValues : this.values);\n        let newKeys = Object.keys(values);\n        for (let i = 0; i < newKeys.length; i++) {\n            if (!keys.includes(newKeys[i])) keys.push(newKeys[i]);\n        }\n        // Traverse backwards, so when removing array items, the whole array gets shifted in the right direction\n        for (let i = keys.length - 1; i >= 0; i--) {\n            let key = keys[i] as keyof T;\n            this.setValue(\n                key,\n                values[key],\n                false, // Will validate after all values are copied\n                isDefault,\n                notifyChild,\n                false, // Will call updateParentValues by itself after all values are copied, see 3 lines down\n                false // Will call fireAnyListener by itself after all values are copied, see 3 lines down\n            );\n        }\n        this.fireAnyListeners();\n        if (notifyParent) this.updateParentValues(isDefault, validate);\n\n        if (validate ?? (this.validateOnChange && this.validator)) this.validate();\n    }\n\n    /**\n     * Set both values and default values for this form. If you only want to set default values, use `setValues(...,...,true)`.\n     * @param values The new default values to set on this form.\n     * @param validate Validate? Overrides `validateOnChange`.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setDefaultValues(values: T, validate: boolean = true, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this.setValues(values, false, true, notifyChild, notifyParent);\n        this.setValues(values, validate, false, notifyChild, notifyParent);\n    }\n\n    /**\n     * Force validation on this form. Required when `validateOnChange` is disabled. **This function works with both asynchronous and synchronous validators.**\n     * @returns true if the form is valid.\n     */\n    public async validate() {\n        if (!this.validator) {\n            return false;\n        }\n        let r = this.validator(this.values);\n        if (r instanceof Promise) r = await r;\n        this.setErrors(r);\n        return !this.error;\n    }\n\n    /**\n     * Force validation on this form. Required when `validateOnChange` is disabled. **This only works if you have a synchronous validator set (not async).**\n     * @returns true if the form is valid.\n     */\n    public validateSync() {\n        if (!this.validator) {\n            return false;\n        }\n        let r = this.validator(this.values);\n        if (r instanceof Promise)\n            throw new Error(\"validateSync() was called on a form with an asynchronous validator set, please use `await form.validate()` instead.\");\n        this.setErrors(r);\n        return !this.error;\n    }\n\n    /**\n     * Sets an error on this form\n     * @param key The field to set an error on.\n     * @param error The error.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     * @param setValuesWasUsed\n     */\n    public setError<Key extends keyof T>(\n        key: Key,\n        error: ErrorType<T[Key], Error> | undefined,\n        notifyChild: boolean = true,\n        notifyParent: boolean = true,\n        fireAny: boolean = true\n    ) {\n        if (typeof error !== \"object\" && this.errorMap[key] === error) return false;\n\n        if (!error) delete this.errorMap[key];\n        else this.errorMap[key] = error;\n\n        if (notifyChild && this.childMap[key]) {\n            if (typeof error === \"object\") {\n                let changed = this.childMap[key]!.setErrors((error as any) ?? {}, true, false);\n                if (!changed) return false;\n            } else {\n                this.childMap[key]!.setErrors({}, true, false);\n            }\n        }\n\n        this.fireListeners(key);\n        if (fireAny) this.fireAnyListeners(); // When setValuesWasUsed, it will call fireAnyListener itself when all values were set\n        if (notifyParent) this.updateParentErrors(); // Will call setError on parent\n        return true;\n    }\n\n    /**\n     * Sets all the errors on this form.\n     * @param errors The new errors for this form. Use {} to clear errors. **The format of this error object must follow the same structure of the values object, but each value is replaced by its error.**\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public setErrors(errors: ErrorMap<T, Error>, notifyChild: boolean = true, notifyParent: boolean = true) {\n        let keys = Object.keys(this.errorMap);\n        let newKeys = Object.keys(errors);\n        for (let i = 0; i < newKeys.length; i++) {\n            if (!keys.includes(newKeys[i])) keys.push(newKeys[i]);\n        }\n        let changed = false;\n        for (let i = keys.length; i >= 0; i--) {\n            let key = keys[i] as keyof T;\n            if (\n                this.setError(\n                    key,\n                    errors[key] as any,\n                    notifyChild,\n                    false, // Will call updateParentErrors by itself after all values have been copied, see 3 lines down\n                    false // Will call fireAnyListener by itself after all values have been copied, see 3 lines down\n                )\n            )\n                changed = true;\n        }\n        if (!changed) return false;\n        this.fireAnyListeners();\n        if (notifyParent) this.updateParentErrors();\n        return true;\n    }\n\n    /**\n     * Reset this form's values to the default values.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public resetAll(validate?: boolean, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this.setValues(this.defaultValues, validate ?? true, false, notifyChild, notifyParent);\n    }\n\n    /**\n     * Reset a form's field to its default value.\n     * @param key The field to reset.\n     * @param notifyChild Should this form notify the child form about this change?\n     * @param notifyParent Should this form notify the parent form about this change?\n     */\n    public reset(key: keyof T, validate?: boolean, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this.setValue(key, this.defaultValues[key], validate ?? true, false, notifyChild, notifyParent);\n    }\n\n    /**\n     * Sets the state for this form, and also on child and parent forms by default.\n     * @param newState The new form state.\n     * @param notifyChild Set the state on the child too?\n     * @param notifyParent Set the state on the parent too?\n     */\n    public setState(newState: State, notifyChild: boolean = true, notifyParent: boolean = true) {\n        this._state = newState;\n\n        let c = Object.keys(this.values);\n        if (notifyChild) c.forEach((e) => this.childMap[e]?.setState(newState, notifyChild, notifyParent));\n\n        c.forEach((e) => this.fireListeners(e as keyof T));\n        this.fireAnyListeners();\n        if (notifyParent) this.updateParentState();\n    }\n\n    /**\n     * Listen for changes on a field, will trigger when value, defaultValue, dirty and error changes for a field. Make sure you pass its return value back to `ignore()` after you are done listening.\n     * @param key The field to listen to.\n     * @param listener Change callback.\n     */\n    public listen(key: keyof T, listener: ListenerCallback): string {\n        if (!this.listeners) this.listeners = {};\n        let setters = this.listeners[key];\n        if (!setters) {\n            setters = {};\n            this.listeners[key] = setters;\n        }\n        let id = \"\" + this.counter++;\n        setters[id] = listener;\n        return id;\n    }\n\n    /**\n     * Listen for any change on this form. Make sure you pass its return value back to `ignoreAny()` after you are done listening.\n     * @param listener Change callback.\n     */\n    public listenAny(listener: ListenerCallback) {\n        if (!this.anyListeners) this.anyListeners = {};\n        let id = \"\" + this.counter++;\n        this.anyListeners[id] = listener;\n        return id;\n    }\n\n    /**\n     * Ignore changes on a field.\n     * @param key The field to ignore.\n     * @param id The callback to ignore.\n     */\n    public ignore(key: keyof T, id: string) {\n        if (!this.listeners) return;\n        let setters = this.listeners[key];\n        if (!setters) {\n            console.warn(\"Ignore was called for no reason\", key, id);\n            return;\n        }\n        delete setters[id];\n    }\n\n    /**\n     * Ignore changes on this form.\n     * @param id The callback to ignore.\n     */\n    public ignoreAny(id: string) {\n        if (!this.anyListeners) return;\n        delete this.anyListeners[id];\n    }\n\n    protected fireListeners(key: keyof T) {\n        let a = this.listeners[key];\n        if (a) {\n            let l = Object.keys(a!);\n            l.forEach((e) => a![e]!());\n        }\n    }\n\n    protected fireAnyListeners() {\n        let al = Object.keys(this.anyListeners);\n        al.forEach((e) => this.anyListeners[e]!());\n    }\n\n    protected updateParentValues(_isDefault: boolean, _validate: boolean | undefined) {\n        // Not implemented for root form, as it does not have a parent\n    }\n\n    protected updateParentErrors() {\n        // Not implemented for root form, as it does not have a parent\n    }\n\n    protected updateParentState() {\n        // Not implemented for root form, as it does not have a parent\n    }\n}\n\nexport class ChildFormState<Parent, Key extends keyof Parent, ParentState, ParentError extends string> extends FormState<\n    NonNullable<Parent[Key]>,\n    ParentState,\n    ParentError\n> {\n    public name: Key;\n    public readonly parent: FormState<Parent, ParentState, ParentError>;\n\n    public constructor(parent: FormState<Parent, ParentState, ParentError>, name: Key) {\n        super(\n            parent.values[name] ?? ({} as any),\n            parent.defaultValues[name] ?? ({} as any),\n            parent.state,\n            undefined,\n            parent.validateOnMount,\n            parent.validateOnChange\n        );\n        this.parent = parent;\n        this.name = name;\n    }\n\n    protected updateParentValues(isDefault: boolean, validate: boolean | undefined) {\n        this.parent.setValueInternal(\n            this.name,\n            isDefault ? memberCopy(this.defaultValues) : memberCopy(this.values),\n            this.dirty,\n            validate,\n            isDefault,\n            false,\n            true,\n            true\n        );\n    }\n\n    protected updateParentErrors() {\n        this.parent.setError(this.name, this.error ? (memberCopy(this.errorMap) as any) : undefined, false, true);\n    }\n\n    protected updateParentState() {\n        this.parent.setState(memberCopy(this.state), false, true);\n    }\n}\n","import { useRef, useEffect, useState, useCallback } from \"react\";\nimport { DefaultState, DefaultError, FormState, ChildFormState, Validator } from \"./form\";\n\n/**\n * Creates a new root form.\n * This hook doesn't cause a rerender.\n * @param defaultValues The default values for this form.\n * @param validator The validator to use, optional.\n * @param validateOnChange Validate on change? Optional, default is false.\n * @param validateOnMount Validate on mount? Optional, default is false.\n * @param defaultState The default state for this form. Form state contains custom global states, example: isSubmitting, isLoading ... Optional, default is `{ isSubmitting: false }`.\n */\nexport function useForm<T, State = DefaultState, Error extends string = DefaultError>(\n    defaultValues: T,\n    validator?: Validator<T, Error>,\n    validateOnChange = false,\n    validateOnMount = false,\n    defaultState?: State\n) {\n    let c = useRef<FormState<T, State, Error> | null>(null);\n\n    if (!c.current) {\n        c.current = new FormState(\n            defaultValues,\n            defaultValues,\n            defaultState ?? ({ isSubmitting: false } as any),\n            validator,\n            validateOnMount,\n            validateOnChange\n        );\n    }\n\n    useEffect(() => {\n        c.current!.setDefaultValues(defaultValues, c.current!.validateOnMount, true, false);\n    }, [defaultValues]);\n\n    return c.current;\n}\n\n/**\n * Creates a nested form for another root or nested form. You must use this for object and array (see useArrayForm) field.\n * This hook doesn't cause a rerender.\n * @param parentForm The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function useChildForm<T, Key extends keyof T, State = DefaultState, Error extends string = DefaultError>(\n    parentForm: FormState<T, State, Error>,\n    name: Key\n) {\n    let c = useRef<ChildFormState<T, Key, State, Error> | null>(null);\n    if (!c.current) {\n        c.current = new ChildFormState(parentForm, name);\n    }\n\n    useEffect(() => {\n        // Update parent and child form\n        parentForm.childMap[name] = c.current!;\n        c.current!.name = name;\n\n        // First, set new default values, without validating\n        c.current!.setValues(parentForm.defaultValues[name] ?? ({} as any), false, true, true, false);\n        // Then, set new values and validate if needed\n        c.current!.setValues(parentForm.values[name] ?? ({} as any), c.current!.validateOnMount, false, true, true);\n\n        return () => {\n            // Only clear if is not already overwritten\n            if (parentForm.childMap[name] === c.current!) {\n                delete parentForm.childMap[name];\n            }\n        };\n    }, [parentForm, name]);\n\n    return c.current;\n}\n\n/**\n * Listen for changes on a form's field. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <Listener /> instead.\n * @param form The form to listen on.\n * @param name The form's field to listen to.\n */\nexport function useListener<T, Key extends keyof T, State = DefaultState, Error extends string = DefaultError>(\n    form: FormState<T, State, Error>,\n    name: Key\n) {\n    const [, setRender] = useState(0);\n\n    useEffect(() => {\n        let id = form.listen(name, () => {\n            setRender((e) => e + 1);\n        });\n        return () => form.ignore(name, id);\n    }, [form, name]);\n\n    return {\n        value: form.values[name],\n        defaultValue: form.defaultValues[name],\n        setValue: (value: T[Key]) => form.setValue(name, value),\n        dirty: form.dirtyMap[name],\n        error: form.errorMap[name],\n        state: form.state,\n        form\n    };\n}\n\n/**\n * Listens for any change on this form. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <AnyListener /> instead.\n *\n * @param form The form that was passed in.\n */\nexport function useAnyListener<T, State = DefaultState, Error extends string = DefaultError>(form: FormState<T, State, Error>) {\n    const [, setRender] = useState(0);\n\n    useEffect(() => {\n        let id = form.listenAny(() => {\n            setRender((e) => e + 1);\n        });\n        return () => form.ignoreAny(id);\n    }, [form]);\n\n    return form;\n}\n\n/**\n * This is a wrapper around useChildForm, with useful functions to manipulate arrays.\n * This hook does cause a rerender, but only if the array size changes.\n * @param parentForm The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function useArrayForm<Parent, Key extends keyof Parent, ParentState = DefaultState, ParentError extends string = DefaultError>(\n    parentForm: FormState<Parent, ParentState, ParentError>,\n    name: Key\n) {\n    const form = useChildForm(parentForm, name);\n    const oldLength = useRef(-1);\n    const [, setRender] = useState(0);\n\n    // Only rerender when array size changed\n    useEffect(() => {\n        let id = parentForm.listen(name, () => {\n            let val = parentForm.values[name] as any;\n            if (val.length !== oldLength.current) {\n                setRender((i) => i + 1);\n                oldLength.current = val.length;\n            }\n        });\n        return () => parentForm.ignore(name, id);\n    }, []);\n\n    const append = useCallback((value: NonNullable<Parent[Key]>[any]) => {\n        form.setValues([...(form.values as any), value] as any);\n    }, []);\n\n    const remove = useCallback((index: number) => {\n        let newValues = [...(form.values as any)];\n        newValues.splice(index, 1);\n        form.setValues(newValues as any);\n    }, []);\n\n    const clear = useCallback(() => {\n        form.setValues([] as any);\n    }, []);\n\n    const move = useCallback((from: number, to: number) => {\n        if (to === from) return;\n        let newArr = [...(form.values as any)];\n        var target = newArr[from];\n        var increment = to < from ? -1 : 1;\n        for (var k = from; k !== to; k += increment) {\n            newArr[k] = newArr[k + increment];\n        }\n        newArr[to] = target;\n        form.setValues(newArr as any);\n    }, []);\n\n    const swap = useCallback((index: number, newIndex: number) => {\n        if (index === newIndex) {\n            return;\n        }\n        let values = [...(form.values as any)];\n        [values[index], values[newIndex]] = [values[newIndex], values[index]];\n        form.setValues(values as any);\n    }, []);\n\n    return {\n        remove: remove,\n        move: move,\n        swap: swap,\n        clear: clear,\n        append: append,\n        form: form,\n        values: form.values,\n        setValues: form.setValues.bind(form)\n    };\n}\n\n/**\n * Listen for truthy changes (if a value becomes truthy or falsy) on a form's field. Behaves like useState.\n * @param form The form to listen on.\n * @param name The form's field to listen to.\n */\nexport function useTruthyListener<T, Key extends keyof T, State = DefaultState, Error extends string = DefaultError>(\n    form: FormState<T, State, Error>,\n    name: Key\n) {\n    const oldTruthy = useRef(!!form.values[name]);\n    const [, setRender] = useState(0);\n\n    useEffect(() => {\n        let id = form.listen(name, () => {\n            let thruthly = !!form.values[name];\n            if (thruthly !== oldTruthy.current) {\n                setRender((i) => i + 1);\n                oldTruthy.current = thruthly;\n            }\n        });\n        return () => form.ignore(name, id);\n    }, []);\n\n    return !form.values[name];\n}\n","import React, { useMemo } from \"react\";\nimport { InputHTMLAttributes } from \"react\";\nimport { DefaultError, DefaultState, FormState } from \"../form\";\nimport { useListener } from \"../hooks\";\n\ntype BaldInputProps = Omit<InputHTMLAttributes<HTMLInputElement>, \"name\" | \"form\" | \"value\" | \"type\">;\n\nexport const DEFAULT_DIRTY_CLASS = \"typed-form-dirty\";\nexport const DEFAULT_ERROR_CLASS = \"typed-form-error\";\n\nexport function getClassName(...args: any) {\n    return [...args].filter((e) => !!e).join(\" \");\n}\n\nexport type FormInputCheckMode = \"normal\" | \"setNull\" | \"setUndefined\";\n\nexport type FormInputType =\n    | \"number\"\n    | \"text\"\n    | \"password\"\n    | \"date\"\n    | \"datetime-local\"\n    | \"radio\"\n    | \"checkbox\"\n    | \"color\"\n    | \"email\"\n    | \"text\"\n    | \"month\"\n    | \"url\"\n    | \"week\"\n    | \"time\"\n    | \"tel\"\n    | \"range\";\n\nexport type FormInputProps<T, State, Error extends string, Key extends keyof T, Value extends T[Key] | T[Key][keyof T[Key]]> = BaldInputProps & {\n    form: FormState<T, State, Error>;\n    name: Key;\n    type?: FormInputType;\n    value?: Value;\n    errorClassName?: string;\n    errorStyle?: React.CSSProperties;\n    dirtyClassName?: string;\n    dirtyStyle?: React.CSSProperties;\n    disableOnSubmitting?: boolean;\n    dateAsNumber?: boolean;\n    setNullOnUncheck?: boolean;\n    setUndefinedOnUncheck?: boolean;\n    hideWhenNull?: boolean;\n};\n\n/**\n * The builtin form input. You must always specify **form** and **name**. Use the **type** prop to specify what type of field it represents.\n *\n * **FormSelect**, **FormTextArea** and **FormError** are also available.\n *\n * When this component does not satisfy your needs, you can always [create your own](https://github.com/CodeStix/typed-react-form/wiki/Custom-inputs#example-custom-input).\n */\nexport function FormInput<\n    T,\n    Key extends keyof T,\n    Value extends T[Key] | T[Key][keyof T[Key]],\n    State extends DefaultState = DefaultState,\n    Error extends string = DefaultError\n>({\n    form,\n    name,\n    style,\n    className,\n    disableOnSubmitting,\n    dateAsNumber,\n    errorClassName,\n    errorStyle,\n    dirtyClassName,\n    dirtyStyle,\n    setUndefinedOnUncheck,\n    setNullOnUncheck,\n    hideWhenNull,\n    value: inputValue,\n    checked: inputChecked,\n    ...rest\n}: FormInputProps<T, State, Error, Key, Value>) {\n    const { value: currentValue, error, dirty, state, setValue, defaultValue } = useListener(form, name);\n\n    let [inValue, inChecked] = useMemo(() => {\n        let inValue = undefined,\n            inChecked = undefined;\n        switch (rest.type) {\n            case \"number\": {\n                inValue = (currentValue ?? \"\") + \"\";\n                break;\n            }\n            case \"datetime-local\":\n            case \"date\": {\n                let n = currentValue as any;\n                if (typeof n === \"string\") {\n                    let ni = parseInt(n);\n                    if (!isNaN(ni)) n = ni;\n                }\n                let d = new Date(n);\n                if (d.getTime() === d.getTime()) {\n                    // Trick to check if date is valid: NaN === NaN returns false\n                    inValue = d?.toISOString().split(\"T\")[0] ?? \"\";\n                } else {\n                    inValue = \"\";\n                }\n                break;\n            }\n            case \"radio\": {\n                inChecked = currentValue === inputValue;\n                break;\n            }\n            case \"checkbox\": {\n                if (setNullOnUncheck) {\n                    inChecked = currentValue !== null;\n                } else if (setUndefinedOnUncheck) {\n                    inChecked = currentValue !== undefined;\n                } else if (inputValue !== undefined) {\n                    inChecked = (Array.isArray(currentValue) ? currentValue : []).includes(inputValue as never);\n                } else {\n                    inChecked = !!currentValue;\n                }\n                break;\n            }\n            default: {\n                inValue = (currentValue ?? \"\") + \"\";\n                break;\n            }\n        }\n        return [inValue, inChecked];\n    }, [rest.type, currentValue, inputValue]);\n\n    if (hideWhenNull && (currentValue === null || currentValue === undefined)) return null;\n\n    if ((setNullOnUncheck || setUndefinedOnUncheck) && rest.type !== \"checkbox\")\n        console.warn(\"setNullOnUncheck/setUndefinedOnUncheck only has an effect on checkboxes.\");\n\n    return (\n        <input\n            style={{\n                ...style,\n                ...(dirty && dirtyStyle),\n                ...(error && errorStyle)\n            }}\n            className={getClassName(className, dirty && (dirtyClassName ?? DEFAULT_DIRTY_CLASS), error && (errorClassName ?? DEFAULT_ERROR_CLASS))}\n            disabled={(disableOnSubmitting ?? true) && state.isSubmitting}\n            value={inValue}\n            checked={inChecked}\n            onChange={(ev) => {\n                let newValue = ev.target.value;\n                let newChecked = ev.target.checked;\n                switch (rest.type) {\n                    case \"number\": {\n                        setValue(parseFloat(newValue) as any);\n                        return;\n                    }\n                    case \"datetime-local\":\n                    case \"date\": {\n                        if (newValue) {\n                            let d = new Date(newValue);\n                            setValue((dateAsNumber ? d.getTime() : d) as any);\n                        } else {\n                            setValue(null as any);\n                        }\n                        return;\n                    }\n                    case \"radio\": {\n                        // Enum field\n                        if (newChecked) {\n                            setValue(inputValue as any);\n                        }\n                        return;\n                    }\n                    case \"checkbox\": {\n                        if (setNullOnUncheck || setUndefinedOnUncheck) {\n                            if (newChecked && inputValue === undefined && !defaultValue)\n                                console.warn(\n                                    \"Toggling checkbox using setNullOnUncheck got checked but a value to set was not found, please provide the value prop\"\n                                );\n                            setValue(\n                                newChecked ? (inputValue !== undefined ? inputValue : defaultValue) : ((setNullOnUncheck ? null : undefined) as any)\n                            );\n                        } else if (inputValue !== undefined) {\n                            // Primitive array field\n                            let arr = Array.isArray(currentValue) ? [...currentValue] : [];\n                            if (newChecked) arr.push(inputValue);\n                            else arr.splice(arr.indexOf(inputValue), 1);\n                            setValue(arr as any);\n                        } else {\n                            // Boolean field\n                            setValue(newChecked as any);\n                        }\n                        return;\n                    }\n                    default: {\n                        // String field\n                        setValue(newValue as any);\n                        return;\n                    }\n                }\n            }}\n            name={name as string}\n            {...rest}\n        />\n    );\n}\n","// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { Validator } from \"./form\";\n\n// yup type stubs\ninterface YupValidationError {\n    path?: string;\n    message?: string;\n    inner: YupValidationError[];\n}\ninterface YupValidationOptions {\n    strict?: boolean;\n    abortEarly?: boolean;\n    stripUnknown?: boolean;\n    recursive?: boolean;\n    context?: any;\n}\n\nexport function yupValidator<T, Error extends string = string>(\n    yupSchema: any,\n    options?: YupValidationOptions,\n    messageTransformer?: (message: string) => Error\n): Validator<T, Error> {\n    return async (values: T) => {\n        try {\n            await yupSchema.validate(values, options);\n            return {};\n        } catch (ex) {\n            return yupErrorToErrorMap(ex, messageTransformer ?? ((e) => e));\n        }\n    };\n}\n\nexport function yupErrorToErrorMap<Error>(error: YupValidationError, errorTransformer: (message: string) => Error) {\n    let errors = error.path ? [error] : error.inner;\n    let obj = {};\n    for (let i = 0; i < errors.length; i++) {\n        let err = errors[i];\n        if (!err.path || !err.message) continue;\n        let pathSegments = Array.from(err.path.matchAll(/(\\w+)/gi)).map((e) => e[0]);\n        let o = obj;\n        for (let j = 0; j < pathSegments.length; j++) {\n            let key = pathSegments[j];\n            let oo = o[key];\n            if (!oo) {\n                oo = {};\n                o[key] = oo;\n            }\n            if (j === pathSegments.length - 1) {\n                o[key] = errorTransformer(err.message);\n            } else {\n                o = oo;\n            }\n        }\n    }\n    return obj;\n}\n","import React from \"react\";\nimport { ChildFormState, DefaultError, DefaultState, DirtyMap, ErrorMap, FormState } from \"./form\";\nimport { useArrayForm, useListener, useAnyListener, useChildForm, useTruthyListener } from \"./hooks\";\n\n/**\n * Wrapper around useArrayForm (which is a wrapper around useChildForm).\n * Exports useful functions to manipulate arrays.\n * This hook does cause a rerender, but only if the whole array becomes null/undefined.\n * @param parent The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function ArrayForm<Parent, Key extends keyof Parent, ParentState = DefaultState, ParentError extends string = DefaultError>(props: {\n    form: FormState<Parent, ParentState, ParentError>;\n    name: Key;\n    render?: (props: {\n        form: ChildFormState<Parent, Key, ParentState, ParentError>;\n        remove: (index: number) => void;\n        clear: () => void;\n        move: (index: number, newIndex: number) => void;\n        swap: (index: number, newIndex: number) => void;\n        append: (value: NonNullable<Parent[Key]>[any]) => void;\n        values: NonNullable<Parent[Key]>;\n        setValues: (values: NonNullable<Parent[Key]>) => void;\n    }) => React.ReactNode;\n}) {\n    const childForm = useArrayForm(props.form, props.name);\n\n    // Causes a rerender when the array becomes null/not null\n    useTruthyListener(props.form, props.name);\n\n    // Do not render anything if the parent field is falsly\n    if (!props.form.values[props.name]) return null;\n    return <React.Fragment>{props.render?.(childForm) ?? childForm.values + \"\"}</React.Fragment>;\n}\n\n/**\n * Wrapper around useListener\n * Listen for changes on a form's field. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <Listener /> instead.\n * @param form The form to listen on.\n * @param name The form's field to listen to.\n */\nexport function Listener<T, Key extends keyof T, State = DefaultState, Error extends string = DefaultError>(props: {\n    form: FormState<T, State, Error>;\n    name: Key;\n    render?: (props: {\n        value: T[Key];\n        defaultValue: T[Key];\n        setValue: (value: T[Key]) => void;\n        dirty: DirtyMap<T>[Key];\n        error: ErrorMap<T, Error>[Key];\n        state: State;\n        form: FormState<T, State, Error>;\n    }) => React.ReactNode;\n}) {\n    const l = useListener(props.form, props.name);\n    return <React.Fragment>{props.render?.(l) ?? l.value + \"\"}</React.Fragment>;\n}\n\n/**\n * Wrapper around useAnyListener.\n * Listens for any change on this form. Behaves like useState.\n * You shouldn't use this hook in large components, as it rerenders each time something changes. Use the wrapper <AnyListener /> instead.\n * @param form The form that was passed in.\n */\nexport function AnyListener<T, State = DefaultState, Error extends string = DefaultError>(props: {\n    form: FormState<T, State, Error>;\n    render?: (props: FormState<T, State, Error>) => React.ReactNode;\n}) {\n    const l = useAnyListener(props.form);\n    return <React.Fragment>{props.render?.(l) ?? l.values + \"\"}</React.Fragment>;\n}\n\n/**\n * Wrapper around useChildForm\n * Creates a child form for another root or child form. You must use this for object and array (see useArrayForm) fields.\n * This hook does cause a rerender, but only if the object field becomes null/undefined.\n * @param parentForm The parent form.\n * @param name The parent's field to create a child form for.\n */\nexport function ChildForm<Parent, Key extends keyof Parent, ParentState = DefaultState, ParentError extends string = DefaultError>(props: {\n    form: FormState<Parent, ParentState, ParentError>; // Use the parent prop instead of the form prop when using ChildForm.\n    name: Key;\n    render?: (props: ChildFormState<Parent, Key, ParentState, ParentError>) => React.ReactNode;\n}) {\n    const childForm = useChildForm(props.form, props.name);\n    // Causes a rerender when the object value becomes null/undefined\n    useTruthyListener(props.form, props.name);\n\n    // Do not render anything if the parent field is falsly\n    if (!props.form.values[props.name]) return null;\n    return <React.Fragment>{props.render?.(childForm)}</React.Fragment>;\n}\n","import React, { HTMLAttributes } from \"react\";\nimport { DefaultError, FormState } from \"../form\";\nimport { useListener } from \"../hooks\";\n\nexport type FormErrorProps<T, Key extends keyof T, Error extends string = DefaultError> = Omit<\n    HTMLAttributes<HTMLParagraphElement>,\n    \"name\" | \"form\"\n> & {\n    form: FormState<T, any, Error>;\n    name: Key;\n};\n\n/**\n * The builtin form error. You must always specify **form** and **name**.\n *\n * **FormInput**, **FormTextArea** and **FormSelect** are also available.\n *\n * When this error component is too basic for your needs, you can always [create your own](https://github.com/CodeStix/typed-react-form/wiki/FormError#custom-error-component).\n */\nexport function FormError<T, Key extends keyof T, Error extends string = DefaultError>({ form, name, ...rest }: FormErrorProps<T, Key, Error>) {\n    const { error } = useListener(form, name);\n    if (!error || typeof error === \"object\") return null;\n    return <p {...rest}>{error + \"\"}</p>;\n}\n","import React, { SelectHTMLAttributes } from \"react\";\nimport { DefaultError, DefaultState, FormState } from \"../form\";\nimport { DEFAULT_DIRTY_CLASS, DEFAULT_ERROR_CLASS, getClassName } from \"./FormInput\";\nimport { useListener } from \"../hooks\";\n\nexport type FormSelectProps<T, State, Error extends string> = Omit<SelectHTMLAttributes<HTMLSelectElement>, \"form\" | \"name\"> & {\n    form: FormState<T, State, Error>;\n    name: keyof T;\n    errorClassName?: string;\n    errorStyle?: React.CSSProperties;\n    dirtyClassName?: string;\n    dirtyStyle?: React.CSSProperties;\n    disableOnSubmitting?: boolean;\n    hideWhenNull?: boolean;\n};\n\n/**\n * The builtin form select. You must always specify **form** and **name**. Use the normal `<option>` element to specify its possible values.\n *\n * **FormInput**, **FormTextArea** and **FormError** are also available.\n *\n * When this component does not satisfy your needs, you can always [create your own](https://github.com/CodeStix/typed-react-form/wiki/Custom-inputs#example-custom-input).\n */\nexport function FormSelect<T, State extends DefaultState = DefaultState, Error extends string = DefaultError>({\n    form,\n    name,\n    errorClassName,\n    errorStyle,\n    dirtyClassName,\n    dirtyStyle,\n    disableOnSubmitting,\n    hideWhenNull,\n    children,\n    className,\n    style,\n    ...rest\n}: FormSelectProps<T, State, Error>) {\n    const { value, setValue, state, dirty, error } = useListener(form, name);\n    if (hideWhenNull && (value === null || value === undefined)) return null;\n    return (\n        <select\n            style={{\n                ...style,\n                ...(dirty && dirtyStyle),\n                ...(error && errorStyle)\n            }}\n            className={getClassName(className, dirty && (dirtyClassName ?? DEFAULT_DIRTY_CLASS), error && (errorClassName ?? DEFAULT_ERROR_CLASS))}\n            disabled={(disableOnSubmitting ?? true) && state.isSubmitting}\n            value={value as any}\n            onChange={(ev) => {\n                if (rest.multiple) setValue(Array.from(ev.target.selectedOptions).map((e) => e.value) as any);\n                else setValue(ev.target.value as any);\n            }}\n            {...rest}\n        >\n            {children}\n        </select>\n    );\n}\n","import React, { TextareaHTMLAttributes } from \"react\";\nimport { DefaultError, DefaultState, FormState } from \"../form\";\nimport { DEFAULT_DIRTY_CLASS, DEFAULT_ERROR_CLASS, getClassName } from \"./FormInput\";\nimport { useListener } from \"../hooks\";\n\nexport type FormTextAreaProps<T, State, Error extends string> = Omit<TextareaHTMLAttributes<HTMLTextAreaElement>, \"form\" | \"name\"> & {\n    form: FormState<T, State, Error>;\n    name: keyof T;\n    errorClassName?: string;\n    errorStyle?: React.CSSProperties;\n    dirtyClassName?: string;\n    dirtyStyle?: React.CSSProperties;\n    disableOnSubmitting?: boolean;\n    hideWhenNull?: boolean;\n};\n\n/**\n * The builtin form textarea. You must always specify **form** and **name**.\n *\n * **FormSelect**, **FormInput** and **FormError** are also available.\n *\n * When this component does not satisfy your needs, you can always [create your own](https://github.com/CodeStix/typed-react-form/wiki/Custom-inputs#example-custom-input).\n */\nexport function FormTextArea<T, State extends DefaultState = DefaultState, Error extends string = DefaultError>({\n    form,\n    name,\n    errorClassName,\n    errorStyle,\n    dirtyClassName,\n    dirtyStyle,\n    disableOnSubmitting,\n    children,\n    className,\n    hideWhenNull,\n    style,\n    ...rest\n}: FormTextAreaProps<T, State, Error>) {\n    const { value, setValue, state, dirty, error } = useListener(form, name);\n    if (hideWhenNull && (value === null || value === undefined)) return null;\n    return (\n        <textarea\n            style={{\n                ...style,\n                ...(dirty && dirtyStyle),\n                ...(error && errorStyle)\n            }}\n            className={getClassName(className, dirty && (dirtyClassName ?? DEFAULT_DIRTY_CLASS), error && (errorClassName ?? DEFAULT_ERROR_CLASS))}\n            disabled={(disableOnSubmitting ?? true) && state.isSubmitting}\n            value={value as any}\n            onChange={(ev) => setValue(ev.target.value as any)}\n            {...rest}\n        >\n            {children}\n        </textarea>\n    );\n}\n","import React, { useRef } from \"react\";\n\nexport function VisualRender(props: { children: React.ReactNode }) {\n    let ref = useRef<HTMLDivElement>(null);\n    let timeoutRef = useRef<number | null>(null);\n\n    if (ref.current) {\n        ref.current.className = \"\";\n        if (timeoutRef.current) clearTimeout(timeoutRef.current);\n        timeoutRef.current = window.setTimeout(() => {\n            ref.current && (ref.current.className = \"blink\");\n        }, 100);\n    }\n\n    return (\n        <div className=\"blink\" ref={ref}>\n            {props.children}\n        </div>\n    );\n}\n","import React, { useState } from \"react\";\nimport {\n    AnyListener,\n    ArrayForm,\n    FormError,\n    FormState,\n    FormInput,\n    FormSelect,\n    useAnyListener,\n    useChildForm,\n    useForm,\n    Listener,\n    FormTextArea,\n    ChildForm,\n    yupValidator,\n    useArrayForm,\n    memberCopy\n} from \"typed-react-form\";\nimport { VisualRender } from \"./VisualRender\";\nimport * as yup from \"yup\";\n\ninterface ExampleFormData {\n    id: number;\n    name: string;\n    description: string;\n    author: User | null;\n    public: boolean;\n    date: number;\n    dateObject: Date;\n    language: \"en\" | \"nl\" | \"fr\";\n    tags: string[];\n    todos: Todo[];\n}\n\ninterface Todo {\n    message: string;\n    priority: \"low\" | \"normal\" | \"high\";\n}\n\ninterface User {\n    name: string;\n    age: number;\n}\n\nexport default function App() {\n    return (\n        <div>\n            <div style={{ padding: \"2em\", background: \"#333\", color: \"white\" }}>\n                <h1>\n                    Example form created using{\" \"}\n                    <a style={{ color: \"#3793ee\" }} href=\"https://github.com/CodeStix/typed-react-form\">\n                        typed-react-form\n                    </a>\n                </h1>\n                <p>\n                    The <strong style={{ color: \"red\" }}>red flash</strong> indicates which parts of the form are being rerendered. The{\" \"}\n                    <strong style={{ outline: \"3px solid gray\" }}>gray outline</strong> indicates that a field is dirty (modified) and the{\" \"}\n                    <strong style={{ outline: \"3px solid red\" }}>red outline</strong> indicates an error.\n                </p>\n                <p>\n                    Every part of this form's{\" \"}\n                    <a style={{ color: \"#3793ee\" }} href=\"https://github.com/CodeStix/typed-react-form/blob/master/example/src/App.tsx\">\n                        source code\n                    </a>{\" \"}\n                    is type-checked.\n                </p>\n            </div>\n            <Form />\n        </div>\n    );\n}\n\nconst initialValues: ExampleFormData = {\n    id: Math.ceil(Math.random() * 100000),\n    name: \"My todo list\",\n    description: \"this is a testing form\",\n    author: null,\n    public: true,\n    date: new Date(\"1990-01-12T00:00:00.000Z\").getTime(),\n    dateObject: new Date(\"1990-01-12T00:00:00.000Z\"),\n    tags: [\"test\"],\n    language: \"en\",\n    todos: [{ message: \"This is a todo\", priority: \"normal\" }]\n};\n\nconst TodoListSchema = yup.object({\n    name: yup.string().required(\"Enter a name\").min(5, \"Enter a longer name\"),\n    language: yup.string().oneOf([\"en\", \"nl\"], \"Must be english or dutch\"),\n    todos: yup.array().of(\n        yup.object({\n            message: yup.string().required(\"Enter a todo\")\n        })\n    )\n});\n\nexport function ArrayTest() {\n    const [values, setValues] = useState({ name: \"a list\", items: [\"asdf\"] });\n    const form = useForm(values);\n    const arrayForm = useArrayForm(form, \"items\");\n\n    return (\n        <form\n            onSubmit={(ev) => {\n                ev.preventDefault();\n                console.log(form.values);\n                setValues(memberCopy(form.values));\n            }}\n        >\n            <p>Name</p>\n            <FormInput form={form} name=\"name\" />\n            <p>Items</p>\n            <ul>\n                {arrayForm.values.map((_, i) => (\n                    <li>\n                        <FormInput key={i} form={arrayForm.form} name={i} />\n                        <button type=\"button\" onClick={() => arrayForm.remove(i)}>\n                            Remove\n                        </button>\n                    </li>\n                ))}\n            </ul>\n            <button type=\"button\" onClick={() => arrayForm.append(\"\")}>\n                Add item\n            </button>\n            <button>Submit</button>\n        </form>\n    );\n}\n\nexport function Form() {\n    const form = useForm(\n        initialValues, // <- Default values, may change\n        yupValidator(TodoListSchema, { abortEarly: false }), // <- Validator (optional)\n        false, // <- Validate on change (optional)\n        false // <- Validate on mount (optional)\n    );\n\n    return (\n        <form\n            onSubmit={async (ev) => {\n                ev.preventDefault();\n\n                await form.validate(); // Validate manually when validateOnChange is disabled.\n                if (form.error) return; // Do not submit if errors\n\n                form.setState({ isSubmitting: true }); // Set the form state (updates every component listening for state updates)\n\n                await new Promise((res) => setTimeout(res, 1000)); // Fake fetch\n\n                form.setState({ isSubmitting: false }); // Set the form state (updates every component listening for state updates)\n                form.setDefaultValues(form.values); // Set new default values\n            }}\n        >\n            <div style={{ display: \"grid\", gridTemplateColumns: \"60% 40%\", gridTemplateRows: \"100%\", gap: \"2em\", margin: \"2em\" }}>\n                <VisualRender>\n                    <h3>\n                        Id <small>number</small>\n                    </h3>\n                    <FormInput type=\"number\" form={form} name=\"id\" />\n                    <hr />\n                    <h3>\n                        Name <small>string</small>\n                    </h3>\n                    <FormInput form={form} name=\"name\" />\n                    <FormError form={form} name=\"name\" />\n                    <hr />\n                    <h3>\n                        Public? <small>boolean</small>\n                    </h3>\n                    <p>Using radio buttons</p>\n                    <label>\n                        <FormInput type=\"radio\" form={form} name=\"public\" value={false} /> no\n                    </label>\n                    <label>\n                        <FormInput type=\"radio\" form={form} name=\"public\" value={true} /> yes\n                    </label>\n                    <p>Using checkbox</p>\n                    <label>\n                        <FormInput type=\"checkbox\" form={form} name=\"public\" /> yes/no\n                    </label>\n                    <hr />\n                    <h3>\n                        Language <small>enum</small>\n                    </h3>\n                    <p>Using select</p>\n                    <FormSelect form={form} name=\"language\">\n                        <option value=\"en\">English</option>\n                        <option value=\"nl\">Dutch</option>\n                        <option value=\"fr\">French</option>\n                    </FormSelect>\n                    <FormError form={form} name=\"language\" />\n                    <p>Using radio buttons</p>\n                    <label>\n                        <FormInput type=\"radio\" form={form} name=\"language\" value=\"en\" /> English\n                    </label>\n                    <label>\n                        <FormInput type=\"radio\" form={form} name=\"language\" value=\"nl\" /> Dutch\n                    </label>\n                    <label>\n                        <FormInput type=\"radio\" form={form} name=\"language\" value=\"fr\" /> French\n                    </label>\n                    <hr />\n                    <h3>\n                        Todo's <small>dynamic array</small>\n                    </h3>\n                    {/* Use ArrayForm (wrapper around useArrayForm) to create dynamic forms */}\n                    <FormError form={form} name=\"todos\" />\n                    <ArrayForm\n                        form={form}\n                        name=\"todos\"\n                        render={(\n                            { form, swap, remove, append, values, setValues } // <- Make sure to use the newly passed form (otherwise type checking will not work!)\n                        ) => (\n                            <VisualRender>\n                                <pre>{form.values.length}</pre>\n                                <ul>\n                                    {form.values.map((\n                                        _,\n                                        i // You should use other key than index\n                                    ) => (\n                                        <TodoItem swap={swap} remove={remove} key={i} parent={form} index={i} />\n                                    ))}\n                                </ul>\n                                <button\n                                    type=\"button\"\n                                    onClick={() => {\n                                        append({\n                                            message: \"\",\n                                            priority: \"normal\"\n                                        });\n                                    }}\n                                >\n                                    Add item\n                                </button>\n                                <button\n                                    type=\"button\"\n                                    onClick={() => {\n                                        setValues([\n                                            ...values,\n                                            ...Array(10)\n                                                .fill(0)\n                                                .map((_, i) => ({\n                                                    message: \"Fix this \" + i,\n                                                    priority: \"normal\" as \"normal\" // Wut\n                                                }))\n                                        ]);\n                                    }}\n                                >\n                                    Add 10 items\n                                </button>\n                            </VisualRender>\n                        )}\n                    />\n                    <button type=\"button\" onClick={() => form.setError(\"todos\", \"There is something wrong with the array\")}>\n                        Set array error\n                    </button>\n                    <hr />\n                    <h3>\n                        Date <small>timestamp number</small>\n                    </h3>\n                    <FormInput type=\"date\" form={form} name=\"date\" dateAsNumber />\n                    <hr />\n                    <h3>\n                        Date <small>date object</small>\n                    </h3>\n                    <FormInput type=\"date\" form={form} name=\"dateObject\" />\n                    <Listener\n                        form={form}\n                        name=\"dateObject\"\n                        render={({ value }) => <p>Your age is {new Date().getFullYear() - value.getFullYear()}</p>}\n                    />\n                    <hr />\n                    <h3>\n                        Tags <small>string array</small>\n                    </h3>\n                    <p>\n                        Using select with <code>multiple=true</code>\n                    </p>\n                    <FormSelect form={form} name=\"tags\" multiple>\n                        <option value=\"test\">Test</option>\n                        <option value=\"fun\">Fun</option>\n                        <option value=\"school\">School</option>\n                    </FormSelect>\n                    <p>Using checkboxes</p>\n                    <label>\n                        <FormInput form={form} name=\"tags\" type=\"checkbox\" value=\"test\" />\n                        Test\n                    </label>\n                    <label>\n                        <FormInput form={form} name=\"tags\" type=\"checkbox\" value=\"fun\" />\n                        Fun\n                    </label>\n                    <label>\n                        <FormInput form={form} name=\"tags\" type=\"checkbox\" value=\"school\" />\n                        School\n                    </label>\n                    <hr />\n                    <h3>Togglable object field</h3>\n                    <label>\n                        <FormInput form={form} name=\"author\" type=\"checkbox\" setNullOnUncheck value={{ name: \"\", age: 0 }} />\n                        Enable author\n                    </label>\n                    <ChildForm\n                        form={form}\n                        name=\"author\"\n                        render={(form) => (\n                            <VisualRender>\n                                <div style={{ background: \"#0001\", padding: \"1em\" }}>\n                                    <p>Name</p>\n                                    <FormInput form={form} name=\"name\" />\n                                    <p>Age</p>\n                                    <FormInput form={form} name=\"age\" type=\"number\" />\n                                </div>\n                            </VisualRender>\n                        )}\n                    />\n                    <hr />\n                    <h3>\n                        Description <small>string</small>\n                    </h3>\n                    <p>\n                        Using <code>FormTextArea</code>\n                    </p>\n                    <FormTextArea form={form} name=\"description\" rows={5} cols={50} />\n                    <p>\n                        Using <code>Listener</code> around <code>textarea</code>\n                    </p>\n                    <Listener\n                        form={form}\n                        name=\"description\"\n                        render={({ value, setValue }) => (\n                            <textarea rows={5} cols={50} value={value} onChange={(ev) => setValue(ev.target.value)}></textarea>\n                        )}\n                    />\n                </VisualRender>\n                <div style={{ position: \"sticky\", top: \"0\", height: \"500px\" }}>\n                    <h2>Output</h2>\n                    <FormValues form={form} />\n\n                    {/* Disable buttons when form is submitting or when nothing has changed, the AnyListener wrapper is required */}\n                    <AnyListener\n                        form={form}\n                        render={({ state, dirty }) => (\n                            <div style={{ margin: \"0.5em 0\" }}>\n                                <button style={{ fontSize: \"1.3em\" }} disabled={state.isSubmitting || !dirty}>\n                                    Submit\n                                </button>\n                                <button\n                                    style={{ fontSize: \"1.3em\" }}\n                                    disabled={state.isSubmitting || !dirty}\n                                    type=\"button\"\n                                    onClick={() => form.resetAll()}\n                                >\n                                    Reset\n                                </button>\n                            </div>\n                        )}\n                    />\n\n                    <div>\n                        <button style={{ fontSize: \"1.3em\" }} type=\"button\" onClick={() => form.validate()}>\n                            Validate\n                        </button>\n                        <label>\n                            <code>validateOnChange</code>\n                            <input\n                                type=\"checkbox\"\n                                defaultChecked={form.validateOnChange}\n                                onChange={(e) => (form.validateOnChange = e.target.checked)}\n                            />\n                        </label>\n                    </div>\n                </div>\n            </div>\n        </form>\n    );\n}\n\nfunction TodoItem(props: {\n    key: number;\n    parent: FormState<Todo[]>;\n    index: number;\n    swap: (a: number, b: number) => void;\n    remove: (a: number) => void;\n}) {\n    // Use a child form, each layer in the object is a seperate form: TodoList (useForm) -> Todo[] (useArrayForm) -> Todo (useChildForm)\n    const form = useChildForm(props.parent, props.index);\n\n    return (\n        <li\n            style={{\n                padding: \"0.5em\"\n            }}\n        >\n            <VisualRender>\n                <FormInput form={form} name=\"message\" />\n                <FormSelect form={form} name=\"priority\">\n                    <option value=\"low\">Low</option>\n                    <option value=\"normal\">Normal</option>\n                    <option value=\"high\">High</option>\n                </FormSelect>\n                <button type=\"button\" onClick={() => props.swap(props.index, 0)}>\n                    Go to top\n                </button>\n                <button type=\"button\" onClick={() => props.remove(props.index)}>\n                    Remove\n                </button>\n            </VisualRender>\n        </li>\n    );\n}\n\n/**\n *  Shows a JSON representation of a form\n */\nfunction FormValues<T>(props: { form: FormState<T> }) {\n    const form = useAnyListener(props.form);\n    const [show, setShow] = useState({ values: true, defaultValues: false, errorMap: true, dirtyMap: true, state: false });\n    return (\n        <VisualRender>\n            <div style={{ background: \"#0001\", overflow: \"hidden\", padding: \"1em\", borderRadius: \"1em\" }}>\n                <p>\n                    <strong style={{ color: form.dirty ? \"blue\" : undefined }}>{form.dirty ? \"Modified\" : \"Unmodified\"}</strong>\n                </p>\n                <p>\n                    <strong style={{ color: form.error ? \"red\" : undefined }}>{form.error ? \"Has error\" : \"No errors\"}</strong>\n                </p>\n\n                <div>\n                    <strong>Show: </strong>\n                    <label>\n                        <input type=\"checkbox\" checked={show.values} onChange={(ev) => setShow({ ...show, values: ev.target.checked })} />\n                        <code>values</code>\n                    </label>\n                    <label>\n                        <input\n                            type=\"checkbox\"\n                            checked={show.defaultValues}\n                            onChange={(ev) => setShow({ ...show, defaultValues: ev.target.checked })}\n                        />\n                        <code>defaultValues</code>\n                    </label>\n                    <label>\n                        <input type=\"checkbox\" checked={show.errorMap} onChange={(ev) => setShow({ ...show, errorMap: ev.target.checked })} />\n                        <code>errorMap</code>\n                    </label>\n                    <label>\n                        <input type=\"checkbox\" checked={show.dirtyMap} onChange={(ev) => setShow({ ...show, dirtyMap: ev.target.checked })} />\n                        <code>dirtyMap</code>\n                    </label>\n                    <label>\n                        <input type=\"checkbox\" checked={show.state} onChange={(ev) => setShow({ ...show, state: ev.target.checked })} />\n                        <code>state</code>\n                    </label>\n                </div>\n\n                {show.values && <pre>values = {JSON.stringify(form.values, null, 2)}</pre>}\n                {show.defaultValues && <pre>defaultValues = {JSON.stringify(form.defaultValues, null, 2)}</pre>}\n                {show.errorMap && <pre>errorMap = {JSON.stringify(form.errorMap, null, 2)}</pre>}\n                {show.dirtyMap && <pre>dirtyMap = {JSON.stringify(form.dirtyMap, null, 2)}</pre>}\n                {show.state && <pre>state = {JSON.stringify(form.state, null, 2)}</pre>}\n            </div>\n        </VisualRender>\n    );\n}\n\n// You should use a validation library (yup, class-validator) instead of this mess...\n// function validateTodoList(values: ExampleFormData) {\n//     let todoErrors = values.todos.reduce((prev, val, index) => {\n//         if (val.message.length < 5) {\n//             prev[index] = { message: \"Todo message should be longer!\" };\n//         }\n//         return prev;\n//     }, [] as any[]);\n//     return {\n//         // author: values.author.length < 3 ? \"Author name is too short.\" : undefined,\n//         name: values.name.length < 3 ? \"Title is too short.\" : undefined,\n//         todos: todoErrors.length > 0 ? todoErrors : undefined\n//     };\n// }\n","import React from \"react\";\nimport { AnyListener, FormInput, FormState, Listener, useChildForm, useForm } from \"typed-react-form\";\n\ninterface Apple {\n    type: \"apple\";\n    color: string;\n}\n\ninterface Bread {\n    type: \"bread\";\n    size: number;\n}\n\ninterface FormData {\n    breadOrApple: Apple | Bread;\n}\n\nexport default function OneOfObjectArrayForm() {\n    const form = useForm<FormData>({\n        breadOrApple: { type: \"apple\", color: \"#ff0000\" } // or { type: \"bread\", size: 200 }\n    });\n    return (\n        <form\n            style={{ margin: \"0.5em\" }}\n            onReset={() => form.resetAll()}\n            onSubmit={async (ev) => {\n                // Prevent the submit button from reloading the page\n                ev.preventDefault();\n                // Disable inputs and fake submit...\n                form.setState({ isSubmitting: true });\n                await new Promise((res) => setTimeout(res, 500));\n                form.setState({ isSubmitting: false });\n                console.log(form.values);\n                form.setDefaultValues(form.values);\n            }}\n        >\n            <a href=\"https://github.com/CodeStix/typed-react-form/blob/master/example/src/OneOfObjectForm.tsx\">View source code</a>\n\n            {/* Our custom form component */}\n            <AppleOrBreadForm parent={form} />\n\n            {/* Shows a live representation of the form values */}\n            <AnyListener\n                form={form}\n                render={({ values, dirty }) => (\n                    <pre>\n                        {dirty ? \"MODIFIED\" : \"UNMODIFIED\"}\n                        <br />\n                        {JSON.stringify(values, null, 2)}\n                    </pre>\n                )}\n            />\n\n            <button>Submit!</button>\n            <button type=\"reset\">Reset</button>\n        </form>\n    );\n}\n\nfunction AppleOrBreadForm(props: { parent: FormState<FormData> }) {\n    // Create a new form based on the 'breadOrApple' field\n    const form = useChildForm(props.parent, \"breadOrApple\");\n    return (\n        <div style={{ background: \"#0001\", padding: \"1em\", margin: \"1em\" }}>\n            <label>Object type: </label>\n            {/* You can also use the useListener hook instead */}\n            <Listener\n                form={form}\n                name=\"type\"\n                render={({ value }) => (\n                    <>\n                        {/* A select input that sets new form values when a new object type (apple or bread) was chosen */}\n                        <select\n                            value={value}\n                            onChange={(ev) => {\n                                if (ev.target.value === \"apple\") form.setValues({ type: \"apple\", color: \"#ff0000\" });\n                                else if (ev.target.value === \"bread\") form.setValues({ type: \"bread\", size: 200 });\n                            }}\n                        >\n                            <option value=\"apple\">Apple</option>\n                            <option value=\"bread\">Bread</option>\n                        </select>\n\n                        {/* Render AppleForm when the type is 'apple'. When type is 'bread', render BreadForm */}\n                        {value === \"apple\" ? <AppleForm form={form as FormState<Apple>} /> : <BreadForm form={form as FormState<Bread>} />}\n                    </>\n                )}\n            />\n        </div>\n    );\n}\n\nfunction AppleForm({ form }: { form: FormState<Apple> }) {\n    return (\n        <div>\n            <h4>Apple editor</h4>\n            <p>Select the color of your apple</p>\n            <FormInput form={form} type=\"color\" name=\"color\" />\n        </div>\n    );\n}\n\nfunction BreadForm({ form }: { form: FormState<Bread> }) {\n    return (\n        <div>\n            <h4>Bread editor</h4>\n            <p>Select the size of your bread</p>\n            <FormInput form={form} type=\"number\" name=\"size\" />\n        </div>\n    );\n}\n","import React from \"react\";\nimport { AnyListener, ArrayForm, FormInput, FormState, useChildForm, useForm, useListener } from \"typed-react-form\";\n\ninterface Apple {\n    type: \"apple\";\n    color: string;\n}\n\ninterface Bread {\n    type: \"bread\";\n    size: number;\n}\n\ntype FormDataObject = Apple | Bread;\n\ninterface FormData {\n    objects: FormDataObject[];\n}\n\nexport default function OneOfObjectArrayForm() {\n    const form = useForm<FormData>({\n        objects: [\n            { type: \"apple\", color: \"#ff0000\" },\n            { type: \"bread\", size: 200 }\n        ]\n    });\n    return (\n        <form\n            style={{ margin: \"0.5em\" }}\n            onReset={() => form.resetAll()}\n            onSubmit={async (ev) => {\n                // Prevent the submit button from reloading the page\n                ev.preventDefault();\n                // Disable inputs and fake submit...\n                form.setState({ isSubmitting: true });\n                await new Promise((res) => setTimeout(res, 500));\n                form.setState({ isSubmitting: false });\n                console.log(form.values);\n                form.setDefaultValues(form.values);\n            }}\n        >\n            <a href=\"https://github.com/CodeStix/typed-react-form/blob/master/example/src/OneOfObjectArrayForm.tsx\">View source code</a>\n            <ArrayForm\n                form={form}\n                name=\"objects\"\n                render={({ form, values, append, remove }) => (\n                    <>\n                        <ul>\n                            {values.map((_, i) => (\n                                // Use index as key\n                                <li key={i}>\n                                    {/* Make sure to use the form given by ArrayForm! */}\n                                    <BreadOrAppleForm parent={form} index={i} remove={() => remove(i)} />\n                                </li>\n                            ))}\n                        </ul>\n                        <hr />\n                        <button type=\"button\" onClick={() => append({ type: \"apple\", color: \"#ff0000\" })}>\n                            Add Apple\n                        </button>\n                        <button type=\"button\" onClick={() => append({ type: \"bread\", size: 200 })}>\n                            Add Bread\n                        </button>\n                    </>\n                )}\n            />\n            <AnyListener\n                form={form}\n                render={({ values, dirty }) => (\n                    <pre>\n                        {dirty ? \"MODIFIED\" : \"UNMODIFIED\"}\n                        <br />\n                        {JSON.stringify(values, null, 2)}\n                    </pre>\n                )}\n            />\n            <button>Submit!</button>\n            <button type=\"reset\">Reset</button>\n        </form>\n    );\n}\n\nfunction BreadOrAppleForm(props: { parent: FormState<FormDataObject[]>; index: number; remove: () => void }) {\n    // Create a new child form with the array as the parent and index as the key\n    const form = useChildForm(props.parent, props.index);\n    // Listen for changes on the 'type' field, which contains 'apple' or 'bread'. This component will rerender when it changes\n    const { value: type } = useListener(form, \"type\");\n    return (\n        <div style={{ background: \"#0001\", padding: \"1em\", margin: \"1em\" }}>\n            {/* A select input that sets new form values when a new object type (apple or bread) was chosen */}\n            <label>Object type: </label>\n            <select\n                value={type}\n                onChange={(ev) => {\n                    if (ev.target.value === \"apple\") form.setValues({ type: \"apple\", color: \"red\" });\n                    else if (ev.target.value === \"bread\") form.setValues({ type: \"bread\", size: 200 });\n                }}\n            >\n                <option value=\"apple\">Apple</option>\n                <option value=\"bread\">Bread</option>\n            </select>\n\n            {/* Render AppleForm when the type is 'apple'. When type is 'bread', render BreadForm */}\n            {type === \"apple\" ? <AppleForm form={form as FormState<Apple>} /> : <BreadForm form={form as FormState<Bread>} />}\n\n            {/* Remove this item from the list */}\n            <button type=\"button\" onClick={() => props.remove()}>\n                Remove\n            </button>\n        </div>\n    );\n}\n\nfunction AppleForm({ form }: { form: FormState<Apple> }) {\n    return (\n        <div>\n            <h4>Apple editor</h4>\n            <p>Select the color of your apple</p>\n            <FormInput form={form} type=\"color\" name=\"color\" />\n        </div>\n    );\n}\n\nfunction BreadForm({ form }: { form: FormState<Bread> }) {\n    return (\n        <div>\n            <h4>Bread editor</h4>\n            <p>Select the size of your bread</p>\n            <FormInput form={form} type=\"number\" name=\"size\" />\n        </div>\n    );\n}\n","import \"./index.css\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport OneOfObjectForm from \"./OneOfObjectForm\";\nimport OneOfObjectArrayForm from \"./OneOfObjectArrayForm\";\n\nfunction Router() {\n    switch (window.location.hash) {\n        case \"#object-types\":\n            return <OneOfObjectForm />;\n        case \"#object-types-array\":\n            return <OneOfObjectArrayForm />;\n        default:\n            return <App />;\n    }\n}\n\nReactDOM.render(<Router />, document.getElementById(\"root\"));\n"],"sourceRoot":""}